{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"workspaceName": {
			"type": "string",
			"metadata": "Workspace name",
			"defaultValue": "synapse-course-workspace"
		},
		"ls_AzureSQLDB_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ls_AzureSQLDB'"
		},
		"ls_AzureSQL_SampleDB_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ls_AzureSQL_SampleDB'"
		},
		"ls_cosmos_nyc_taxi_data_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ls_cosmos_nyc_taxi_data'"
		},
		"ls_serverless_sql_pool_db_nyc_taxi_ldw_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ls_serverless_sql_pool_db_nyc_taxi_ldw'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=tcp:synapse-course-workspace-ondemand.sql.azuresynapse.net,1433;Initial Catalog=nyc_taxi_ldw"
		},
		"synapse-course-workspace-WorkspaceDefaultSqlServer_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'synapse-course-workspace-WorkspaceDefaultSqlServer'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=tcp:synapse-course-workspace.sql.azuresynapse.net,1433;Initial Catalog=@{linkedService().DBName}"
		},
		"RestService1_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://reqres.in"
		},
		"bing-covid-19-data_sasUri": {
			"type": "secureString",
			"metadata": "Secure string for 'sasUri' of 'bing-covid-19-data'"
		},
		"ls_HTTP_FIleExample_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://data.gov.au/"
		},
		"ls_RESTAPI_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://sample-videos.com/"
		},
		"ls_azuresynapsecoursedl_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://azuresynapsecoursedl.dfs.core.windows.net/"
		},
		"ls_http_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://sample-videos.com"
		},
		"synapse-course-workspace-WorkspaceDefaultStorage_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://azuresynapsecoursedl.dfs.core.windows.net"
		},
		"Evetn Trigger_properties_PL_11_Event_Based_Trigger_parameters_sourcePath": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"Evetn Trigger_properties_PL_11_Event_Based_Trigger_parameters_sourceFileName": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"Evetn Trigger_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/1101ab50-b9a6-4719-afe5-7586e598ea9f/resourceGroups/synapse-course-rg/providers/Microsoft.Storage/storageAccounts/azuresynapsecoursedl"
		}
	},
	"variables": {
		"workspaceId": "[concat('Microsoft.Synapse/workspaces/', parameters('workspaceName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('workspaceName'), '/0_pl_execute_all_pipelines')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Execute Create Silver Table",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "3_1_pl_create_silver_tables_usp",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Create Silver Trip Data Green",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "4_2_pl_create_silver_trip_data_green_With StoredProc_Activity",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Create Gold Trip Data Green",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Create Silver Table",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Execute Create Silver Trip Data Green",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "5_pl_create_gold_trip_data_green_With StoredProc_Activity",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Create Gold Trip Data Green Agg SPARK Notebook",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Create Silver Trip Data Green",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "6_pl_spark_create_gold_trip_data_green_agg",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/3_1_pl_create_silver_tables_usp')]",
				"[concat(variables('workspaceId'), '/pipelines/4_2_pl_create_silver_trip_data_green_With StoredProc_Activity')]",
				"[concat(variables('workspaceId'), '/pipelines/5_pl_create_gold_trip_data_green_With StoredProc_Activity')]",
				"[concat(variables('workspaceId'), '/pipelines/6_pl_spark_create_gold_trip_data_green_agg')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/10_LogPipeLineExecutionsThruDataFlowTasks')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "WaitFor2Seconds",
						"type": "Wait",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 2
						}
					},
					{
						"name": "CheckIfLogFileExists",
						"type": "GetMetadata",
						"dependsOn": [
							{
								"activity": "Set LogFileName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_LogFileDetails",
								"type": "DatasetReference",
								"parameters": {
									"parFileName": {
										"value": "@variables('varLogFileName')",
										"type": "Expression"
									}
								}
							},
							"fieldList": [
								"exists"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "Set LogFileName",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "WaitFor2Seconds",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varLogFileName",
							"value": {
								"value": "@concat(formatDateTime(utcnow(),'yyyy-MM-dd'),'_log.csv')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "IfLogFileExists",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "CheckIfLogFileExists",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@activity('CheckIfLogFileExists').output.exists",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Data flow When LogFileDoes Not  Exists",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "10_DF_LogFile_Create",
											"type": "DataFlowReference",
											"parameters": {
												"ADFName": {
													"value": "'@{pipeline().DataFactory}'",
													"type": "Expression"
												},
												"PipeLineName": {
													"value": "'@{pipeline().Pipeline}'",
													"type": "Expression"
												},
												"Status": {
													"value": "'@{'Success'}'",
													"type": "Expression"
												},
												"RunId": {
													"value": "'@{pipeline().RunId}'",
													"type": "Expression"
												},
												"TriggerName": {
													"value": "'@{pipeline().TriggerName}'",
													"type": "Expression"
												},
												"ExecutedOn": {
													"value": "'@{pipeline().TriggerTime}'",
													"type": "Expression"
												},
												"FileName": {
													"value": "'@{variables('varLogFileName')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"SampleFileSource": {},
												"WriteToLogFile": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Data flow When Log ile Exists",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "10_DF_LogFile_Append",
											"type": "DataFlowReference",
											"parameters": {
												"ADFName": {
													"value": "'@{pipeline().DataFactory}'",
													"type": "Expression"
												},
												"PipeLineName": {
													"value": "'@{pipeline().Pipeline}'",
													"type": "Expression"
												},
												"Status": {
													"value": "'@{'Success'}'",
													"type": "Expression"
												},
												"RunId": {
													"value": "'@{pipeline().RunId}'",
													"type": "Expression"
												},
												"TriggerName": {
													"value": "'@{pipeline().TriggerName}'",
													"type": "Expression"
												},
												"ExecutedOn": {
													"value": "'@{pipeline().TriggerTime}'",
													"type": "Expression"
												},
												"FileName": {
													"value": "'@{variables('varLogFileName')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"SampleFileSource": {},
												"LogFileSource": {},
												"sink1": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varLogFileName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_LogFileDetails')]",
				"[concat(variables('workspaceId'), '/dataflows/10_DF_LogFile_Create')]",
				"[concat(variables('workspaceId'), '/dataflows/10_DF_LogFile_Append')]",
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/11_SCD_Type1')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "DF_SCDType1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "11_DF_SCDType1",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"SourceToEmployee": {},
									"WriteToDB": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/11_DF_SCDType1')]",
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/12_CountofFileinaFolder_usingVariables')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "GetFolderInformation",
						"description": "Get Information About \"demo\" cotainer",
						"type": "GetMetadata",
						"dependsOn": [
							{
								"activity": "SetStartVariableValue",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_demo",
								"type": "DatasetReference",
								"parameters": {}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "SetStartVariableValue",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varStart",
							"value": {
								"value": "0",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ForEachFile",
						"description": "Count the No of Files inside the Folder . If there is a Folder inside the Folder , ignore that Folder",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "GetFolderInformation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('GetFolderInformation').output.childItems",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Set variable1",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Var2",
										"value": {
											"value": "@if(equals(item().type,'Folder'),string(add(int(variables('varStart')),0 )),string(add(int(variables('varStart')),1 )))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set variable2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set variable1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varStart",
										"value": {
											"value": "@variables('Var2')",
											"type": "Expression"
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varStart": {
						"type": "String"
					},
					"Var2": {
						"type": "String"
					},
					"varFileCount": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/12_CountofFilesinaFolder')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get Metadata1",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_demo",
								"type": "DatasetReference",
								"parameters": {}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "Set variable",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Get Metadata1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varFileCount",
							"value": {
								"value": "@string(length(activity('Get Metadata1').output.childItems))",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varFileCount": {
						"type": "String"
					},
					"arrAppendVar": {
						"type": "Array"
					},
					"varFileCount2": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/13_AdditionalColumnsinCopyActivity')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy Employee",
						"description": "Copy Employee.TXT with Additional Columns",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Set variable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"additionalColumns": [
									{
										"name": "SourceFileName",
										"value": "$$FILEPATH"
									},
									{
										"name": "PipeLineNAme",
										"value": {
											"value": "@pipeline().Pipeline",
											"type": "Expression"
										}
									},
									{
										"name": "TriggeredTime",
										"value": {
											"value": "@pipeline().TriggerTime",
											"type": "Expression"
										}
									},
									{
										"name": "CurrentTime",
										"value": {
											"value": "@variables('varUTCNOW')",
											"type": "Expression"
										}
									},
									{
										"name": "Country1",
										"value": "$$COLUMN:COUNTRY"
									}
								],
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "EMPID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "EMPID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "EMPNAME",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "EMPNAME",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "AGE",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AGE",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "COUNTRY",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "COUNTRY",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "SALARY",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SALARY",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "SourceFileName",
											"type": "String"
										},
										"sink": {
											"name": "SourceFileName",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "PipeLineNAme",
											"type": "String"
										},
										"sink": {
											"name": "PipeLineNAme",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "TriggeredTime",
											"type": "String"
										},
										"sink": {
											"name": "TriggeredTime",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "CurrentTime",
											"type": "String"
										},
										"sink": {
											"name": "CurrentTime",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Country1",
											"type": "String"
										},
										"sink": {
											"name": "Country1",
											"type": "String",
											"physicalType": "String"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_Employee",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_demoOutput",
								"type": "DatasetReference",
								"parameters": {
									"prTargetFolderName": {
										"value": "@variables('varUTCNOW')",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Set variable",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varUTCNOW",
							"value": {
								"value": "@formatDateTime(utcnow(),'yyyy-MM-dd')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varUTCNOW": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_Employee')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demoOutput')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/14_ConvertArraytoString')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "LookupEmployee",
						"description": "Requirement is to Read a FIle with Single Column and generate a String with comma separated value",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"dataset": {
								"referenceName": "ds_Employee",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ForEachEmployee",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "LookupEmployee",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('LookupEmployee').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Set EmployeeName",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varTempEployeeName",
										"value": {
											"value": "@variables('varAppendEmpNames')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set variable to Append Name",
									"description": "Variable to Append Names with Semicolon Separated",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set EmployeeName",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varAppendEmpNames",
										"value": {
											"value": "@concat(variables('varTempEployeeName'),item().EMPNAME,';')",
											"type": "Expression"
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varTempEployeeName": {
						"type": "String"
					},
					"varAppendEmpNames": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_Employee')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/15_JoinFunctionToConvertArraytoString')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "LookupEmployeeFIle",
						"description": "Lookup to \"demo/Employee.txt\" to get the  EMPNAME Only",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"dataset": {
								"referenceName": "ds_Employee",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "LoopThruAllEMPNames",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "LookupEmployeeFIle",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('LookupEmployeeFIle').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "AppendToArrayVariable",
									"description": "Append to Array Variable",
									"type": "AppendVariable",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"variableName": "varEmpNamesArray",
										"value": {
											"value": "@item().EMPNAME",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "ArraytoString",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "LoopThruAllEMPNames",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varEpNames",
							"value": {
								"value": "@join(variables('varEmpNamesArray'),';')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varEmpNamesArray": {
						"type": "Array"
					},
					"varEpNames": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_Employee')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/16_FileSchemaMetadataValidation')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get Employee FIle Metadata",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_Employee",
								"type": "DatasetReference",
								"parameters": {}
							},
							"fieldList": [
								"structure"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "Get EmployeeReference File Metadata",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_EmployeeReference",
								"type": "DatasetReference",
								"parameters": {}
							},
							"fieldList": [
								"structure"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "If SchemMatches",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Get Employee FIle Metadata",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Get EmployeeReference File Metadata",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(activity('Get EmployeeReference File Metadata').output.structure,activity('Get Employee FIle Metadata').output.structure )",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailDuetoFIleSchemaMisMatch",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": {
											"value": "'Schema MisMatch '+@{activity('Get Employee FIle Metadata').output.structure} + @{activity('Get EmployeeReference File Metadata').output.structure}",
											"type": "Expression"
										},
										"errorCode": "1000"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "WaitFor2Seconds",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_Employee')]",
				"[concat(variables('workspaceId'), '/datasets/ds_EmployeeReference')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/17_SCD_Type2')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "17_DF_SCDType2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"EmployeeFile": {},
									"employeeTable": {},
									"sinkToInsertOnly": {},
									"sink2Update": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/17_DF_SCDType2')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/17_SCD_Type2_ModifiedDate')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "17_DF_SCDType2_ModifiedDate",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"EmployeeFile": {},
									"employeeTable": {},
									"sinkToInsertOnly": {},
									"sink2Update": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/17_DF_SCDType2_ModifiedDate')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/18_Copy_Multiple_Tables_in_Bulk')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Video No : https://www.youtube.com/watch?v=U5pSm0G3Vic&list=PLMWaZteqtEaLacN3eS3s8pw2jtwBVb1BH&index=18\n\n========================\n\n1. Copy Contents of Tables to Different Files\n\n2. Each Table will be written to a separate File\n\n3. File Name will be combination of dbname ,schema , table_name\n\n4. File will be written to the folder : demo/output/<currentdate>/filename",
				"activities": [
					{
						"name": "Lookup1",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "select table_catalog as db_name , table_schema , table_name from information_Schema.tables where table_type = 'BASE TABLE'",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_AzureSQLDB",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup1').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Copy data1",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzureSqlSource",
											"queryTimeout": "02:00:00",
											"partitionOption": "None"
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".txt"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "ds_AzureSQLTable",
											"type": "DatasetReference",
											"parameters": {
												"tableName": {
													"value": "@item().table_name",
													"type": "Expression"
												},
												"schemaName": {
													"value": "@item().table_schema",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "ds_csv",
											"type": "DatasetReference",
											"parameters": {
												"parFileName": {
													"value": "@{item().db_name}_@{item().table_schema}_@{item().table_name}.csv",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_AzureSQLDB')]",
				"[concat(variables('workspaceId'), '/datasets/ds_AzureSQLTable')]",
				"[concat(variables('workspaceId'), '/datasets/ds_csv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/19_Execute Stored Procedure with output Parameters')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "When Your SQL Stored Procedures return some values after execution then , Stored Procedure Activity will not help .\n\nYou will have to use \"lookup activity\" with\nquery options in the setting tab of lookup activity .\n\nlookup1 : it returns empcount by country ( used query option )\n\nlookup2 : to get all employee details \n(used stored procedure option )\n\nforeach : it will loop thru the records of loop2 activity output and insert into \"dimEmployee\" Table using script activity\n\n\nExample :\n------------------------------------\n\nThis Procedure return no of employees for the country . Data used in this procedure\n\nempKey\tempid\tempname\tgender\tcountry\tsalary\tisActive\tstartDate\n1\t1001\tAlex\tMale\tIndia\t5000\t1\t2023-06-28T10:51:56.8270000\n\n\n2\t1002\tNicolas\tFemale\tIndia\t9800\t1\t2023-06-28T10:52:34.1230000\n\n\n3\t1003\tJames\tMale\tEngland\t8855\t1\t2023-06-28T10:53:04.7330000\n\n\n4\t1004\tCummins\tMale\tAustralia\t8455\t1\t2023-06-28T10:53:29.4870000\n\n\n5\t1005\tWarner\tFemale\tAustralia\t4785\t1\t2023-06-28T10:53:53.7300000\n\n\n\n\n\n ",
				"activities": [
					{
						"name": "Stored procedure1",
						"type": "SqlServerStoredProcedure",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[dbo].[getEmployeeDetails]",
							"storedProcedureParameters": {
								"country": {
									"value": "India",
									"type": "String"
								},
								"empCount": {
									"value": "",
									"type": "Int32"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "ls_AzureSQLDB",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "Lookup1 to Execute getEmployeeCountByCountry",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "Script To Truncate dimEpmloyee Table",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "declare @empCount int\nexec getEmployeeCountByCountry @country = 'India' , @empCount =@empCount OUTPUT\nselect @empCount as empCount \n",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_AzureSQLDB",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Lookup2 to execute getEmployeeDetails Procedure",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "Lookup1 to Execute getEmployeeCountByCountry",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderStoredProcedureName": "[dbo].[getEmployeeDetails]",
								"storedProcedureParameters": {
									"country": {
										"type": "String",
										"value": "India"
									}
								},
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_AzureSQLDB",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ForEachEmployee",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Lookup2 to execute getEmployeeDetails Procedure",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup2 to execute getEmployeeDetails Procedure').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Script1",
									"type": "Script",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_AzureSQLDB",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"parameters": [
													{
														"name": "empKey",
														"type": "Int32",
														"value": {
															"value": "@item().empKey",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "empid",
														"type": "Int32",
														"value": {
															"value": "@item().empid",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "empname",
														"type": "String",
														"value": {
															"value": "@item().empname",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "gender",
														"type": "String",
														"value": {
															"value": "@item().gender",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "country",
														"type": "String",
														"value": {
															"value": "@item().country",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "salary",
														"type": "Int32",
														"value": {
															"value": "@item().salary",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "isActive",
														"type": "Int32",
														"value": {
															"value": "@item().isActive",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "startDate",
														"type": "Datetime",
														"value": {
															"value": "@item().startDate",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "endDate",
														"type": "Datetime",
														"value": {
															"value": "@item().endDate",
															"type": "Expression"
														},
														"direction": "Input"
													}
												],
												"type": "NonQuery",
												"text": "insert into dbo.dimEmployee (empKey,empid,empname,gender,country,salary,isActive,startDate,endDate)\nvalues (@empKey,@empid,@empname,@gender,@country,@salary,@isActive,@startDate,@endDate)"
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								}
							]
						}
					},
					{
						"name": "Script To Execute getDimEmployeeDetails",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "ForEachEmployee",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_AzureSQLDB",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"parameters": [
										{
											"name": "country",
											"type": "String",
											"value": "India",
											"direction": "Input"
										}
									],
									"type": "Query",
									"text": "exec getdimEmployeeDetails @country = @country"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "Script To Truncate dimEpmloyee Table",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "Stored procedure1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_AzureSQLDB",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "NonQuery",
									"text": "TRUNCATE TABLE dimEmployee"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQLDB')]",
				"[concat(variables('workspaceId'), '/datasets/ds_AzureSQLDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_pl_create_silver_taxi_zone')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Delete Silver Taxi Zone Folder",
						"type": "Delete",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_silver_taxi_zone",
								"type": "DatasetReference",
								"parameters": {}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "Create Silver Taxi Zone",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "Delete Silver Taxi Zone Folder",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "NonQuery",
									"text": "IF EXISTS (SELECT 1 FROM sys.external_tables WHERE name = 'taxi_zone')\n    DROP EXTERNAL TABLE silver.taxi_zone"
								},
								{
									"type": "NonQuery",
									"text": "CREATE EXTERNAL TABLE silver.taxi_zone\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/taxi_zone'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.taxi_zone"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_silver_taxi_zone')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/20_Get Latest File From Folder_1')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Lets Say you have 10 files in a folder and you want to process only the latest file by comparing the last modified date .\n\nThis Pipeline is going to identify which file is the most recent file .",
				"activities": [
					{
						"name": "Get Metadata1",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_demo",
								"type": "DatasetReference",
								"parameters": {}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "Filter1",
						"description": "As the Parent Folder \"demo\" has folders and files , this will filter down all folder types and keep only Type ='File'",
						"type": "Filter",
						"dependsOn": [
							{
								"activity": "Get Metadata1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Metadata1').output.childItems",
								"type": "Expression"
							},
							"condition": {
								"value": "@equals(item().type,'File' )",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Filter1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Filter1').output.Value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Get Metadata2",
									"type": "GetMetadata",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_demo_file_details",
											"type": "DatasetReference",
											"parameters": {
												"parFileName": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										},
										"fieldList": [
											"itemName",
											"lastModified"
										],
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										},
										"formatSettings": {
											"type": "DelimitedTextReadSettings"
										}
									}
								},
								{
									"name": "Set B4LastModifiedDate",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Get Metadata2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varB4FileModifiedDate",
										"value": {
											"value": "@variables('varA4FileModifiedDate')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Final Last Modified Date",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set B4LastModifiedDate",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varA4FileModifiedDate",
										"value": {
											"value": "@if(greater(activity('Get Metadata2').output.lastModified , variables('varB4FileModifiedDate')) , activity('Get Metadata2').output.lastModified , variables('varB4FileModifiedDate'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set B4FileName",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Get Metadata2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varB4FileName",
										"value": {
											"value": "@variables('varA4FileName')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Final File Name",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set B4FileName",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varA4FileName",
										"value": {
											"value": "@if(greater(activity('Get Metadata2').output.lastModified , variables('varB4FileModifiedDate')) , activity('Get Metadata2').output.itemName , variables('varB4FileName'))",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEach1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": {
										"value": "@variables('varA4FileName')",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_demo",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_target",
								"type": "DatasetReference",
								"parameters": {
									"parTargetFolderName": {
										"value": "Output/@{formatDateTime(utcnow(),'yyyy-MM-dd')}",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varB4FileModifiedDate": {
						"type": "String"
					},
					"varA4FileModifiedDate": {
						"type": "String"
					},
					"varB4FileName": {
						"type": "String"
					},
					"varA4FileName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo')]",
				"[concat(variables('workspaceId'), '/datasets/ds_target')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_file_details')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/20_Get Latest File From Folder_2')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Lets Say you have 10 files in a folder and you want to process only the latest file by comparing the last modified date .\n\nThis Pipeline is going to identify which file is the most recent file .",
				"activities": [
					{
						"name": "Get Metadata1",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_demo",
								"type": "DatasetReference",
								"parameters": {}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "Filter1",
						"description": "As the Parent Folder \"demo\" has folders and files , this will filter down all folder types and keep only Type ='File'",
						"type": "Filter",
						"dependsOn": [
							{
								"activity": "Get Metadata1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Metadata1').output.childItems",
								"type": "Expression"
							},
							"condition": {
								"value": "@equals(item().type,'File' )",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Filter1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Filter1').output.Value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Get Metadata2",
									"type": "GetMetadata",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_demo_file_details",
											"type": "DatasetReference",
											"parameters": {
												"parFileName": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										},
										"fieldList": [
											"itemName",
											"lastModified"
										],
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										},
										"formatSettings": {
											"type": "DelimitedTextReadSettings"
										}
									}
								},
								{
									"name": "If Condition1",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "Get Metadata2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@greater(activity('Get Metadata2').output.lastModified , variables('varLatestModifiedDate'))",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "Set variable2",
												"type": "SetVariable",
												"dependsOn": [],
												"policy": {
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"variableName": "varFileName",
													"value": {
														"value": "@activity('Get Metadata2').output.itemName",
														"type": "Expression"
													}
												}
											},
											{
												"name": "Set variable3",
												"type": "SetVariable",
												"dependsOn": [
													{
														"activity": "Set variable2",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"variableName": "varLatestModifiedDate",
													"value": {
														"value": "@activity('Get Metadata2').output.lastModified",
														"type": "Expression"
													}
												}
											}
										]
									}
								}
							]
						}
					},
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEach1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": {
										"value": "@variables('varFileName')",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_demo_file",
								"type": "DatasetReference",
								"parameters": {
									"parFileName": {
										"value": "@variables('varFileName')",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_target",
								"type": "DatasetReference",
								"parameters": {
									"parTargetFolderName": {
										"value": "Output/@{formatDateTime(adddays(utcnow(),1),'yyyy-MM-dd')}",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varLatestModifiedDate": {
						"type": "String",
						"defaultValue": "1900-01-01"
					},
					"varFileName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_file')]",
				"[concat(variables('workspaceId'), '/datasets/ds_target')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_file_details')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/21_Dynamic_Column_Mapping_in_Copy_Activity')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Let Say you have Multiple Excel Files and you want to load those files into respective tables  with following differences\n\n1. Employee.xlsx file data should go to tbl_Employee Table\n\n2.Department.xlsx file data should go to tbl_Department Table\n\n3. All these files have different Column Names . Means File Column Name and  Table Column Names are different .\n\nThis Pipeline will demonstrate that .",
				"activities": [
					{
						"name": "Get Metadata1",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_demo_source_folder",
								"type": "DatasetReference",
								"parameters": {
									"parFolderName": "21_Dynamic_Column_Mapping"
								}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Metadata1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Metadata1').output.childItems",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Copy data1",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Script1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "ExcelSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											}
										},
										"sink": {
											"type": "AzureSqlSink",
											"writeBehavior": "insert",
											"sqlWriterUseTableLock": false,
											"disableMetricsCollection": false
										},
										"enableStaging": false,
										"translator": {
											"value": "@json(activity('Script1').output.resultSets[0].rows[0].Mapping)",
											"type": "Expression"
										}
									},
									"inputs": [
										{
											"referenceName": "ds_demo_Dynamic_Folder",
											"type": "DatasetReference",
											"parameters": {
												"parFolderName": {
													"value": "@variables('varSourceFolder')",
													"type": "Expression"
												},
												"parFileName": {
													"value": "@activity('Script1').output.resultSets[0].rows[0].SourceFileName",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "ds_AzureSQLTable",
											"type": "DatasetReference",
											"parameters": {
												"tableName": {
													"value": "@activity('Script1').output.resultSets[0].rows[0].Target_Table_Name",
													"type": "Expression"
												},
												"schemaName": {
													"value": "@activity('Script1').output.resultSets[0].rows[0].Target_Table_Schema",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Script1",
									"type": "Script",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_AzureSQLDB",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"parameters": [
													{
														"name": "SourceFileName",
														"type": "String",
														"value": {
															"value": "@item().name",
															"type": "Expression"
														},
														"direction": "Input"
													}
												],
												"type": "Query",
												"text": "select SourceFileName ,Target_Table_Schema  , Target_Table_Name ,Mapping from tbl_Mapping where SourceFileName = @SourceFileName"
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varSourceFolder": {
						"type": "String",
						"defaultValue": "21_Dynamic_Column_Mapping"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo_source_folder')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_Dynamic_Folder')]",
				"[concat(variables('workspaceId'), '/datasets/ds_AzureSQLTable')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQLDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/22_Merge_MUltiple_Rows_into_Single_Row')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "22_MergeMultipleRows_into_SingleRow",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"EnglandCricktersCSV": {},
									"WriteToFolder": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/22_MergeMultipleRows_into_SingleRow')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/23_SendEmailInFailureActivity')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Fail1",
						"type": "Fail",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"message": "It is Intentional Failed",
							"errorCode": "1001"
						}
					},
					{
						"name": "Web1",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Fail1",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": "https://lgapp-emailalert-adf.azurewebsites.net:443/api/EmailADF/triggers/When_a_HTTP_request_is_received/invoke?api-version=2022-05-01&sp=%2Ftriggers%2FWhen_a_HTTP_request_is_received%2Frun&sv=1.0&sig=3-Z0eJTHKXScveEhStMg7yfqgRM9iA9lXghjDxK8vmo",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"method": "POST",
							"headers": {
								"Content-Type": "application/json"
							},
							"body": {
								"value": "{\n\"Pipeline\":\"@{pipeline().Pipeline}\",\n\"ErrorMessage\":\"@{activity('Fail1').Error.Message}\",\n\"DataFactoryName\":\"@{pipeline().DataFactory}\",\n\"ToEmail\":\"starofcloud@outlook.com;starmsahoo@gmail.com\",\n\"Subject\":\"Data Factory Failed at @{utcnow()}\",\n\"FromPersonName\":\"Manoj Sahoo\"\n}\n",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/24_Split_Single_Row_into_Multiple')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "SplitSingleRowintoMultiple",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_24_Split_SingleRowsInto_Multiple",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"SourceToEnglandCricketersSkills": {
										"parFolderName": "24_Split_Single_Row_into_Multiple",
										"parFileName": "EnglandCrickterSkills1.csv"
									},
									"sink1": {
										"parTarget": "24_Split_Single_Row_into_Multiple"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/DF_24_Split_SingleRowsInto_Multiple')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/25_Download_File_From_API')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Requirement : To Copy EXCEL File from an API and Store into a Directory in ADLS Gen 2\n\nSolution :\n1. We Used Copy Activity\n\nSource:\n----------------\n0. Linked Service :  HTTP .\n1. Source Dataset has API Connector Lined Service\n2. File Type is Binary . As we are only Copying we can select it as Binary\n\nTarget:\n-----------------\n0.Linked Service is adlsGen2\n1.TargetDataset is also binary",
				"activities": [
					{
						"name": "Copy Data From API",
						"description": "It Uses Excel as Source Dataset and CSV as Target Dataset as EXCEL SINK Dataset is not supported at the moment",
						"type": "Copy",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "ExcelSource",
								"storeSettings": {
									"type": "HttpReadSettings",
									"requestMethod": "GET"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_API_ExcelFile",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_demoOutput",
								"type": "DatasetReference",
								"parameters": {
									"prTargetFolderName": "25_Download_File_From_API/@{formatDateTime(utcnow(),'yyyy-MM-dd HH:mm:ss')}"
								}
							}
						]
					},
					{
						"name": "Copy Data From API Using Binary Format",
						"description": "It Uses BINARY as Source Dataset and BINARY as Target Dataset as EXCEL SINK Dataset is not supported at the moment",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "HttpReadSettings",
									"requestMethod": "GET"
								},
								"formatSettings": {
									"type": "BinaryReadSettings"
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ds_API_XLS",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_Binary",
								"type": "DatasetReference",
								"parameters": {
									"parTargetFolderName": {
										"value": "25_Download_File_From_API/@{formatDateTime(utcnow(),'yyyy-MM-dd HH:mm:ss')}",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_API_ExcelFile')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demoOutput')]",
				"[concat(variables('workspaceId'), '/datasets/ds_API_XLS')]",
				"[concat(variables('workspaceId'), '/datasets/ds_Binary')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/26_Download_Zip_File_From_API')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Download the Zip File from an API , Unzip it and store it in ADLS Gen 2 .\n\nThe Challenge here is we can't unzip the file directly . Microsoft Suggests \n\n1. Download the Zip File to a Staging Folder using copy activity\n\n2. Then use another copy activity to copy from Staging Folder , UnZip it and save it in the Storage Account.\n\nActivities Used :\n\n1. Set Variable : To Create the Staging Folder Name . It's a Dynamic Name with Date & Time Combined\n\n2. 1st Copy : To copy the Zip file from API to Staging Fodler\n\n3. 2nd Copy : To Copy From Staging Folder , unzip it and save it in ADLS Gen 2 Account.\n\nAPI Used here: https://data.gov.au/data/dataset/5bd7fcab-e315-42cb-8daf-50b7efc2027e/resource/0ae4d427-6fa8-4d40-8e76-c6909b5a071b/download/public_split_1_10.zip\n\n\n\n\n\n",
				"activities": [
					{
						"name": "Copy Zip From API to Staging ADLS Gen2",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Set Target Folder Name",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "HttpReadSettings",
									"requestMethod": "GET"
								},
								"formatSettings": {
									"type": "BinaryReadSettings"
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ds_HTTP_Zip",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_Binary_Zip",
								"type": "DatasetReference",
								"parameters": {
									"parTargetFolderName": {
										"value": "26_Download_Zip_File_From_API/Staging/@{variables('varTargetFolderName')}",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Copy From Staging to Final",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy Zip From API to Staging ADLS Gen2",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": "*.zip.zip",
									"deleteFilesAfterCompletion": false
								},
								"formatSettings": {
									"type": "BinaryReadSettings",
									"compressionProperties": {
										"type": "ZipDeflateReadSettings",
										"preserveZipFileNameAsFolder": false
									}
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ds_Source_Zip_Binary",
								"type": "DatasetReference",
								"parameters": {
									"parSourceFolderName": {
										"value": "@variables('varTargetFolderName')",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_Target_Binary_Unzipped",
								"type": "DatasetReference",
								"parameters": {
									"parTargetFolderName": {
										"value": "@variables('varTargetFolderName')",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Set Target Folder Name",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varTargetFolderName",
							"value": {
								"value": "@formatDateTime(utcnow(),'yyyy-MM-dd HH:mm:ss')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varTargetFolderName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_HTTP_Zip')]",
				"[concat(variables('workspaceId'), '/datasets/ds_Binary_Zip')]",
				"[concat(variables('workspaceId'), '/datasets/ds_Source_Zip_Binary')]",
				"[concat(variables('workspaceId'), '/datasets/ds_Target_Binary_Unzipped')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/27_Round_Decimal_Number_Pipeline_Expression')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Question :\n\n\n\nInput is 123.33421 : Output : 123.33\nInput is 123.31621 : Output : 123.32\nInput is 123.1  : Output : 123.10 \n\n\nSolution  1:\nSet variable using substring\n\nSplit the input value , if the 3rd digit is >= 5 then add 1 else keep as it is .\n\nSolution 2 :\n\nMultiply 100 to the original number , Split it and divide 100 to it again.\n\n",
				"activities": [
					{
						"name": "Set Variable",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varInput",
							"value": {
								"value": "@concat('123.34331','000000000000')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set variable using Multiplier",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set Variable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varCalculate",
							"value": {
								"value": "@string(div(float(split(string(mul(float(variables('varInput')),100)),'.')[0]),100.00))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set variable using substring",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set Variable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varCalculate",
							"value": {
								"value": "@concat(\n            split(variables('varInput'),'.')[0],\n            '.', \n        if( greaterOrEquals(int(substring(split(variables('varInput'),'.')[1],2 ,1)),5), \n                string(add(int( substring(split(variables('varInput'),'.')[1],0 ,2)),1)),\n                substring(split(variables('varInput'),'.')[1],0 ,2)\n          )\n        )",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varInput": {
						"type": "String"
					},
					"varCalculate": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/28_TimeZoneConversion_in_MDF')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Time Zone Conversion",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_28_TimeZone_Conversion_In_MDF",
								"type": "DataFlowReference",
								"parameters": {
									"parFolderName": "'28_TimeZone_Conversion_in_MDF'",
									"parFileName": "'EnglandCricketersEntryTiing.csv'"
								},
								"datasetParameters": {
									"EnglanCricktersEntryTime": {},
									"writeToFolder": {
										"parTarget": "28_TimeZone_Conversion_in_MDF"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/DF_28_TimeZone_Conversion_In_MDF')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/29_Run_Activity_In_Case_of_Failure')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Lets say you have to send an email when any of your activity fails .\n\nYour activities may run in series \n\nYour Activities may run in Parallel\n\n\nWhen running in SERIES :\n++++++++++++++++++\n1.Introduce a WEB Activity as last step\n2. Connect On Failure and On Skip of it's previous activity to it .\n3. if set var1 fails , the set var 2 & set var3 . And on SetVar3 activity we have setu of OnFailure & ON Skip . So this case On Skip will trigger email activity\n\n4. If set var1 succeeds , set var2 fails , so set var3 will be skipped and again it will trigger email activity\n\n5. if set var1 succeeds ,set var2 succeeds and set var3 fails , it will trigger email activity as it connected with ON FAILURE .\n\n\nWhen running in PARALLEL :\n++++++++++++++++++\n1.Introduce a DUMMY WAIT Activity .\nIt will run when all it's previous activity succeeds .\n2. If any of it's connected acitivity fails, this DUMMY ACTIVITY wont run .\n3. When DUMMY ACTIVY won't run which will trigger a SKIP Activity and then it will trigger the WEB EMAIL Activity.",
				"activities": [
					{
						"name": "Series Set variable1",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "series1",
							"value": {
								"value": "\"hello\"",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Series Set variable2",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Series Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "series1",
							"value": "i am runing in series"
						}
					},
					{
						"name": "Series Set variable3",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Series Set variable2",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "series1",
							"value": {
								"value": "@array('abc')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Wait as WEB Activity to send email",
						"type": "Wait",
						"dependsOn": [
							{
								"activity": "Series Set variable3",
								"dependencyConditions": [
									"Failed",
									"Skipped"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					},
					{
						"name": "Parallel Set variable1",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "parallel1",
							"value": {
								"value": "@int(1)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Parallel Set variable2",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "parallel1",
							"value": {
								"value": "\"hello\"",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Parallel Set variable3",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "parallel1",
							"value": {
								"value": "\"hello\"",
								"type": "Expression"
							}
						}
					},
					{
						"name": "DummyWait",
						"type": "Wait",
						"dependsOn": [
							{
								"activity": "Parallel Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Parallel Set variable2",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Parallel Set variable3",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					},
					{
						"name": "WaitforWebEmail",
						"type": "Wait",
						"dependsOn": [
							{
								"activity": "DummyWait",
								"dependencyConditions": [
									"Skipped"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"series1": {
						"type": "String"
					},
					"parallel1": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2_pl_create_silver_taxi_zone_usp')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Delete Silver Taxi Zone Folder",
						"type": "Delete",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_silver_taxi_zone",
								"type": "DatasetReference",
								"parameters": {}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "Create Silver Taxi Zone",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "Delete Silver Taxi Zone Folder",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[silver].[usp_silver_taxi_zone]"
						},
						"linkedServiceName": {
							"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_silver_taxi_zone')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/30_1_Dynamic_Capture_Error_Message')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "\nScenario:\n+++++++++++\n\nCapture error message of activity .\nThese activities are running in parallel.\nIf any activity fails , then capture the message\n\n\nactivity('Set Variable1').Error?.message\n\nactivity('Set Variable1')?.Error?.message\n\nQuestion Mark ( ? ) next to Activity  : This is required for NULL Safe .\nThis wont throw error if the activity hasn't run\n\n\nQuestion Mark ( ? ) next to Property which is  Error here:\nThis wont throw error if the activity doesn't have any error.",
				"activities": [
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": "b"
						}
					},
					{
						"name": "Set variable3",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": {
								"value": "@int('1')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set variable2",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": "a"
						}
					},
					{
						"name": "Wait1",
						"type": "Wait",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Set variable2",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Set variable3",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					},
					{
						"name": "Get Error Message",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Wait1",
								"dependencyConditions": [
									"Skipped"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": {
								"value": "@concat(activity('Set Variable1').Error?.message,'|' , activity('Set Variable2').Error?.message,'|' , activity('Set Variable3').Error?.message)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set variable4 If Previous Activity Skipped",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Wait1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varActivityStatus",
							"value": {
								"value": "@coalesce(activity('Wait1')?.activitytype,'Skipped')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"var1": {
						"type": "String"
					},
					"varActivityStatus": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/30_2_Dynamic_Capture_Error_Message')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "\nScenario:\n+++++++++++\n\nCapture error message of activity .\nThese activities are running in Series.\nIf any activity fails , then capture the message\n\n\nactivity('Set Variable1').Error?.message\n\nactivity('Set Variable1')?.Error?.message\n\nQuestion Mark ( ? ) next to Activity  : This is required for NULL Safe .\nThis wont throw error if the activity hasn't run\n\n\nQuestion Mark ( ? ) next to Property Level which is Error :\nThis wont throw error if the activity doesn't have any error.",
				"activities": [
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": "b"
						}
					},
					{
						"name": "Set variable3",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set variable2",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": {
								"value": "@int('1')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set variable2",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": "a"
						}
					},
					{
						"name": "Wait1",
						"type": "Wait",
						"dependsOn": [
							{
								"activity": "Set variable3",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					},
					{
						"name": "Get Error Message",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Wait1",
								"dependencyConditions": [
									"Skipped"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "var1",
							"value": {
								"value": "@concat(activity('Set Variable1')?.Error?.message,'|' , activity('Set Variable2')?.Error?.message,'|' , activity('Set Variable3')?.Error?.message)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set variable4 If Previous Activity Skipped",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Wait1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varActivityStatus",
							"value": {
								"value": "@coalesce(activity('Wait1')?.activitytype,'Skipped')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"var1": {
						"type": "String"
					},
					"varActivityStatus": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/31_1_Call_Another_ADF_Pipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Web Call Another ADF Pipeline",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": "https://management.azure.com/subscriptions/1101ab50-b9a6-4719-afe5-7586e598ea9f/resourceGroups/poc-rg/providers/Microsoft.DataFactory/factories/adf-demo-for-all/pipelines/childPipeline/createRun?api-version=2018-06-01",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"method": "POST",
							"headers": {},
							"body": {
								"duration": 20
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://management.azure.com/"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"pipelineRunID": {
						"type": "String"
					},
					"pipelineStatus": {
						"type": "String"
					},
					"varStartCounter": {
						"type": "String"
					},
					"varCounter": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/31_2_Call_Another_ADF_Pipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Execute ADF Pipeline using WebActivity\n\nThe Child Activity takes 2 parameters.\n\n1. Duration\n\n2.Who triggered the execution\n\n\nCheck the ADF Execution Status until it's Succeeded or Failed or Cancelled .\n\nNext run the if else activity.",
				"activities": [
					{
						"name": "Web Call Another ADF Pipeline",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": {
								"value": "https://management.azure.com/subscriptions/1101ab50-b9a6-4719-afe5-7586e598ea9f/resourceGroups/poc-rg/providers/Microsoft.DataFactory/factories/adf-demo-for-all/pipelines/@{activity('Lookup1').output.value[0].PiplelineName}/createRun?api-version=2018-06-01",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"method": "POST",
							"headers": {},
							"body": {
								"value": "{\"duration\":@{activity('Lookup1').output.value[0].Duration},\"triggeredBy\":\"@{pipeline().DataFactory}\"}",
								"type": "Expression"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://management.azure.com/"
							}
						}
					},
					{
						"name": "Lookup1",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"dataset": {
								"referenceName": "ds_demo_input_directory_file",
								"type": "DatasetReference",
								"parameters": {
									"parFolderName": "31_ExecutePipelineofAnotherADF",
									"parFileName": "PipelineName.csv"
								}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Web Call Another ADF Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "pipelineStatus",
							"value": {
								"value": "InProgress",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Until1",
						"type": "Until",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@or(or(equals(variables('pipelineStatus'),'Succeeded') , equals(variables('pipelineStatus'),'Cancelled')),equals(variables('pipelineStatus'),'Failed'))",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "Web Call GET AP Status",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "Wait1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"url": {
											"value": "https://management.azure.com/subscriptions/1101ab50-b9a6-4719-afe5-7586e598ea9f/resourceGroups/poc-rg/providers/Microsoft.DataFactory/factories/adf-demo-for-all/pipelineruns/@{activity('Web Call Another ADF Pipeline').output.runId}?api-version=2018-06-01",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "AutoResolveIntegrationRuntime",
											"type": "IntegrationRuntimeReference"
										},
										"method": "GET",
										"headers": {},
										"body": {
											"value": "{\"duration\":@{activity('Lookup1').output.value[0].Duration},\"triggeredBy\":\"@{pipeline().DataFactory}\"}",
											"type": "Expression"
										},
										"authentication": {
											"type": "MSI",
											"resource": "https://management.azure.com/"
										}
									}
								},
								{
									"name": "Set variable2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Web Call GET AP Status",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "pipelineStatus",
										"value": {
											"value": "@activity('Web Call GET AP Status').output.status",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait1",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 10
									}
								}
							],
							"timeout": "0.12:00:00"
						}
					},
					{
						"name": "If Condition1",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Until1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('pipelineStatus'),'Succeeded')",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Wait For Failure Run",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Wait For Succeeded Run",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"pipelineRunID": {
						"type": "String"
					},
					"pipelineStatus": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_input_directory_file')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/32_1_Copy_Data_From_REST_API_Paginated')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Sample API : https://reqres.in/api/users?page=1\n\nRequirement:\n\nDownload data from the API which gives data in different pages  and write to files\n\n1. Connect to REST API\n2. Supply the Page Number\n3. Use the Copy Activity to copy the data from that page and write it to file\n\n",
				"activities": [
					{
						"name": "Web to Sample REST API",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": "https://reqres.in/api/users?page=1",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"method": "GET",
							"headers": {}
						}
					},
					{
						"name": "Set Start Value",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Web to Sample REST API",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varStartCounter",
							"value": "1"
						}
					},
					{
						"name": "Until1",
						"type": "Until",
						"dependsOn": [
							{
								"activity": "Set Start Value",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(add(activity('Web to Sample REST API').output.total_pages,1),int(variables('varStartCounter')))",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "Set variable1",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varCounter",
										"value": {
											"value": "@variables('varStartCounter')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Copy data1",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Set variable1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "RestSource",
											"httpRequestTimeout": "00:01:40",
											"requestInterval": "00.00:00:00.010",
											"requestMethod": "GET",
											"paginationRules": {
												"supportRFC5988": "true"
											}
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".csv"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"path": "['id']"
													},
													"sink": {
														"name": "id"
													}
												},
												{
													"source": {
														"path": "['email']"
													},
													"sink": {
														"name": "email"
													}
												},
												{
													"source": {
														"path": "['first_name']"
													},
													"sink": {
														"name": "first_name"
													}
												},
												{
													"source": {
														"path": "['last_name']"
													},
													"sink": {
														"name": "last_name"
													}
												},
												{
													"source": {
														"path": "['avatar']"
													},
													"sink": {
														"name": "avatar"
													}
												}
											],
											"collectionReference": "$['data']",
											"mapComplexValuesToString": false
										}
									},
									"inputs": [
										{
											"referenceName": "RestAPITO_reqres_dot_in",
											"type": "DatasetReference",
											"parameters": {
												"parPageNo": {
													"value": "@variables('varStartCounter')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "ds_demo_output_directory",
											"type": "DatasetReference",
											"parameters": {
												"parTarget": "32_Copy_Data_From_REST_API_Paginated"
											}
										}
									]
								},
								{
									"name": "Set variable2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Copy data1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varStartCounter",
										"value": {
											"value": "@string(add(int(variables('varCounter')),1))",
											"type": "Expression"
										}
									}
								}
							],
							"timeout": "0.12:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varStartCounter": {
						"type": "String"
					},
					"varCounter": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/RestAPITO_reqres_dot_in')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_output_directory')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/32_2_Copy_Data_From_REST_API_Paginated_copy1')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Sample API : https://reqres.in/api/users?page=1\n\nRequirement:\n\nDownload data from the API which gives data in different pages  and write to files\n\n1. Connect to REST API\n2. Supply the Page Number\n3. Use the Copy Activity to copy the data from that page and write it to file\n\n",
				"activities": [
					{
						"name": "Web to Sample REST API",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": "https://reqres.in/api/users?page=1",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"method": "GET",
							"headers": {}
						}
					},
					{
						"name": "ForEachPage",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Web to Sample REST API",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@range(1,activity('Web to Sample REST API').output.total_pages)",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Copy data1",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "RestSource",
											"httpRequestTimeout": "00:01:40",
											"requestInterval": "00.00:00:00.010",
											"requestMethod": "GET",
											"paginationRules": {
												"supportRFC5988": "true"
											}
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".csv"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"path": "['id']"
													},
													"sink": {
														"name": "id"
													}
												},
												{
													"source": {
														"path": "['email']"
													},
													"sink": {
														"name": "email"
													}
												},
												{
													"source": {
														"path": "['first_name']"
													},
													"sink": {
														"name": "first_name"
													}
												},
												{
													"source": {
														"path": "['last_name']"
													},
													"sink": {
														"name": "last_name"
													}
												},
												{
													"source": {
														"path": "['avatar']"
													},
													"sink": {
														"name": "avatar"
													}
												}
											],
											"collectionReference": "$['data']"
										}
									},
									"inputs": [
										{
											"referenceName": "RestAPITO_reqres_dot_in",
											"type": "DatasetReference",
											"parameters": {
												"parPageNo": {
													"value": "@item()",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "ds_demo_Output_Directoty_N_File",
											"type": "DatasetReference",
											"parameters": {
												"parTargetFolderName": "32_Copy_Data_From_REST_API_Paginated",
												"parTargetFileName": {
													"value": "API_Page_@{item()}",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varStartCounter": {
						"type": "String"
					},
					"varCounter": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/RestAPITO_reqres_dot_in')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_Output_Directoty_N_File')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/33_1_Load_CSV_into_JSON')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"additionalColumns": [
									{
										"name": "Purchases",
										"value": "$$COLUMN:ItemName"
									}
								],
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "JsonSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "JsonWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "CustId",
											"type": "String"
										},
										"sink": {
											"path": "$['CustId']"
										}
									},
									{
										"source": {
											"name": "CustName",
											"type": "String"
										},
										"sink": {
											"path": "$['CustName']"
										}
									},
									{
										"source": {
											"name": "ItemName",
											"type": "String"
										},
										"sink": {
											"path": "$['Purchases']['ItemName']"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "String"
										},
										"sink": {
											"path": "$['Purchases']['Quantity']"
										}
									}
								]
							}
						},
						"inputs": [
							{
								"referenceName": "ds_demo_input_directory_file",
								"type": "DatasetReference",
								"parameters": {
									"parFolderName": "33_Load_CSV_into_JSON",
									"parFileName": "CustomerPurchases.csv"
								}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_Output_JSON",
								"type": "DatasetReference",
								"parameters": {
									"parOutputFolder": {
										"value": "33_Load_CSV_into_JSON",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo_input_directory_file')]",
				"[concat(variables('workspaceId'), '/datasets/ds_Output_JSON')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/33_2_Load_CSV_into_JSON')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_33_2_Load_CSV_into_JSON",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"CustomerPurchases": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/DF_33_2_Load_CSV_into_JSON')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/33_3_Load_CSV_into_JSON_SubColumns')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_33_3_Load_CSV_into_JSON",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"CustomerPurchases": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/DF_33_3_Load_CSV_into_JSON')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/34_1_Dynamic_Pass_Expression_into_MDF')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Process the File with the transformation rule given",
				"activities": [
					{
						"name": "Lookup Transformation rule File",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"dataset": {
								"referenceName": "ds_demo_input_directory_file",
								"type": "DatasetReference",
								"parameters": {
									"parFolderName": "34_Dynamic_Pass_Expression_into_MDF",
									"parFileName": "TransformationRules.csv"
								}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Lookup Transformation rule File",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup Transformation rule File').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Data flow1",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "Dataflow1",
											"type": "DataFlowReference",
											"parameters": {
												"parFileName": {
													"value": "'@{item().filename}'",
													"type": "Expression"
												},
												"parRule": {
													"value": "'@{item().rule}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"employeefile": {},
												"sink1": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo_input_directory_file')]",
				"[concat(variables('workspaceId'), '/dataflows/Dataflow1')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/35_1_Compare_Source_Target_MDF')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "\nThis is Approach No - 1 by Exists Transformation , Hashkey with All columns \n\ncompare Source File with Target File .\n\nOnly Write UnMatched Lines to New File",
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_35_1_Compare_Source_Target_MDF",
								"type": "DataFlowReference",
								"parameters": {
									"parTargetFolder": "\"35_Compare_Source_Target_MDF\""
								},
								"datasetParameters": {
									"SourceData": {},
									"DataToCompareWith": {},
									"WritetoFile": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/DF_35_1_Compare_Source_Target_MDF')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/35_2_Compare_Source_Target_MDF')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "\nThis is Approach No - 2 by using Join , Filter , Hashkey with selected columns \n\ncompare Source File with Target File .\n\nOnly Write UnMatched Lines to New File",
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_35_2_Compare_Source_Target_MDF",
								"type": "DataFlowReference",
								"parameters": {
									"parTargetFolder": "'35_Compare_Source_Target_MDF_2'"
								},
								"datasetParameters": {
									"SourceData": {},
									"DataToCompareWith": {},
									"WriteToFile": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/DF_35_2_Compare_Source_Target_MDF')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/35_Convert_Tablular_Data_To_NestedJson_MDF')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Convert Tablular Data To NestedJson",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_Convert_TablularData_To_NestedJson",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice/Azure Content"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/DF_Convert_TablularData_To_NestedJson')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/36_1_Execute_SQL_Queries_Using_Lookup')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Lookup Employee Skills",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT * FROM dbo.EmployeeSkills",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_SQL_Employee",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ForEachEmployee",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Lookup Employee Skills",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup Employee Skills').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "If Employee is Liam",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "Set variable1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@equals(toUpper(item().name),'LIAM LIVINGSTONE')",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "UpdateEmployeeName",
												"type": "Lookup",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "AzureSqlSource",
														"sqlReaderQuery": {
															"value": "update dbo.EmployeeSkills set name = '@{variables('varNewName')}' where name = '@{variables('varEmployeeOldName')}' ; SELECT 1 AS ID",
															"type": "Expression"
														},
														"queryTimeout": "02:00:00",
														"partitionOption": "None"
													},
													"dataset": {
														"referenceName": "ds_SQL_Employee",
														"type": "DatasetReference",
														"parameters": {}
													}
												}
											}
										]
									}
								},
								{
									"name": "Set variable1",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "varEmployeeOldName",
										"value": {
											"value": "@item().name",
											"type": "Expression"
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varNewName": {
						"type": "String",
						"defaultValue": "LivingStone"
					},
					"varEmployeeOldName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_SQL_Employee')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/36_2_Execute_SQL_Queries_Using_Lookup')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Run DDL Commands using SP_EXECUTESQL Command",
				"activities": [
					{
						"name": "Lookup Employee Skills",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": {
									"value": "EXEC SP_EXECUTESQL N'CREATE SCHEMA demo';\n\nselect 1 as id",
									"type": "Expression"
								},
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_SQL_Employee",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varNewName": {
						"type": "String",
						"defaultValue": "LivingStone"
					},
					"varEmployeeOldName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_SQL_Employee')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/37_1_Check_If_Day_is_WeekDay_or_Not')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "If WeekDay is Holiday",
						"type": "IfCondition",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Set DayOfWeek",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@or(equals(dayOfWeek(utcnow()),0),equals(dayOfWeek(utcnow()),6))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Wait1 for 2 Sec as NOT Weekend",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 2
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Wait1 for 1 Sec as Weekend",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								}
							]
						}
					},
					{
						"name": "Set DayOfWeek",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varDayofWeek",
							"value": {
								"value": "@if(equals(dayOfWeek(utcnow()),0),'Sunday'\n,if(equals(dayOfWeek(utcnow()),1),'Monday'\n,if(equals(dayOfWeek(utcnow()),2),'Tuesday'\n,if(equals(dayOfWeek(utcnow()),3),'Wednesday'\n,if(equals(dayOfWeek(utcnow()),4),'Thursday'\n,if(equals(dayOfWeek(utcnow()),5),'Friday'\n,'Saturday'))))))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "If WeekDay is Holiday Opt 2",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Set DayOfWeek",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@contains('06', string(dayOfWeek(utcNow())))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Wait1 for 2 Sec as NOT Weekend_copy1",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 2
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Wait1 for 1 Sec as Weekend_copy1",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varDayofWeek": {
						"type": "String"
					},
					"varDayName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/37_2_DayName_Of_LastDay_of_PreviousMonth')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "If WeekDay is Holiday",
						"type": "IfCondition",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Set DayOfWeek",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@or(equals(dayOfWeek(utcnow()),0),equals(dayOfWeek(utcnow()),6))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Wait1 for 2 Sec as NOT Weekend",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 2
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Wait1 for 1 Sec as Weekend",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								}
							]
						}
					},
					{
						"name": "Set DayOfWeek",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varDayofWeek",
							"value": {
								"value": "@if(equals(dayOfWeek(variables('varDayName')),0),'Sunday'\r\n    ,if(equals(dayOfWeek(variables('varDayName')),1),'Monday'\r\n    ,if(equals(dayOfWeek(variables('varDayName')),2),'Tuesday'\r\n    ,if(equals(dayOfWeek(variables('varDayName')),3),'Wednesday'\r\n    ,if(equals(dayOfWeek(variables('varDayName')),4),'Thursday'\r\n    ,if(equals(dayOfWeek(variables('varDayName')),5),'Friday'\r\n    ,'Saturday'))))))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "If WeekDay is Holiday Opt 2",
						"type": "IfCondition",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Set DayOfWeek",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@contains('06', string(dayOfWeek(utcNow())))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "Wait1 for 2 Sec as NOT Weekend_copy1",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 2
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "Wait1 for 1 Sec as Weekend_copy1",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								}
							]
						}
					},
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "varDayName",
							"value": {
								"value": "@string( addDays(utcnow(), mul(dayOfMonth(utcNow()),-1))     )",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"varDayofWeek": {
						"type": "String"
					},
					"varDayName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/3_1_pl_create_silver_tables_usp')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ForEach Folder Path",
						"type": "ForEach",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('v_folder_path_usp_name_array')",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Delete Silver Folder",
									"type": "Delete",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_nyc_taxi_data_dynamic",
											"type": "DatasetReference",
											"parameters": {
												"p_folder_path": {
													"value": "@item().folder_path",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										}
									}
								},
								{
									"name": "Create Silver Table",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "Delete Silver Folder",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": {
											"value": "@item().usp_name",
											"type": "Expression"
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"v_folder_path": {
						"type": "String",
						"defaultValue": "silver/taxi_zone"
					},
					"v_usp_name": {
						"type": "String",
						"defaultValue": "silver.usp_silver_taxi_zone"
					},
					"v_folder_path_usp_name_array": {
						"type": "Array",
						"defaultValue": [
							{
								"folder_path": "silver/calendar",
								"usp_name": "silver.usp_silver_calendar"
							},
							{
								"folder_path": "silver/taxi_zone",
								"usp_name": "silver.usp_silver_taxi_zone"
							},
							{
								"folder_path": "silver/trip_type",
								"usp_name": "silver.usp_silver_trip_type"
							},
							{
								"folder_path": "silver/vendor",
								"usp_name": "silver.usp_silver_vendor"
							},
							{
								"folder_path": "silver/rate_code",
								"usp_name": "silver.usp_silver_rate_code"
							},
							{
								"folder_path": "silver/payment_type",
								"usp_name": "silver.usp_silver_payment_type"
							}
						]
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_nyc_taxi_data_dynamic')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/3_2_pl_create_silver_tables_usp_array_set')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ForEach Folder Path",
						"type": "ForEach",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('v_folder_path_usp_name_array')",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Delete Silver Folder",
									"type": "Delete",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_nyc_taxi_data_dynamic",
											"type": "DatasetReference",
											"parameters": {
												"p_folder_path": {
													"value": "@item()[0]",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										}
									}
								},
								{
									"name": "Create Silver Table",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "Delete Silver Folder",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": {
											"value": "@item()[1]",
											"type": "Expression"
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"v_folder_path_usp_name_array": {
						"type": "Array",
						"defaultValue": [
							[
								"silver/calendar",
								"silver.usp_silver_calendar"
							],
							[
								"silver/taxi_zone",
								"silver.usp_silver_taxi_zone"
							],
							[
								"silver/trip_type",
								"silver.usp_silver_trip_type"
							],
							[
								"silver/vendor",
								"silver.usp_silver_vendor"
							],
							[
								"silver/rate_code",
								"silver.usp_silver_rate_code"
							],
							[
								"silver/payment_type",
								"silver.usp_silver_payment_type"
							]
						]
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_nyc_taxi_data_dynamic')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/3_3_pl_create_silver_tables_usp_array_from_file')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ForEach Folder Path",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Lookup_foler_path_usp_name_array",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Lookup_foler_path_usp_name_array').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Delete Silver Folder",
									"type": "Delete",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_nyc_taxi_data_dynamic",
											"type": "DatasetReference",
											"parameters": {
												"p_folder_path": {
													"value": "@item().folder_path",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										}
									}
								},
								{
									"name": "Create Silver Table",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "Delete Silver Folder",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": {
											"value": "@item().usp_name",
											"type": "Expression"
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					},
					{
						"name": "Lookup_foler_path_usp_name_array",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"dataset": {
								"referenceName": "ds_foler_path_usp_name_array",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"v_folder_path_usp_name_array": {
						"type": "Array",
						"defaultValue": [
							[
								"silver/calendar",
								"silver.usp_silver_calendar"
							],
							[
								"silver/taxi_zone",
								"silver.usp_silver_taxi_zone"
							],
							[
								"silver/trip_type",
								"silver.usp_silver_trip_type"
							],
							[
								"silver/vendor",
								"silver.usp_silver_vendor"
							],
							[
								"silver/rate_code",
								"silver.usp_silver_rate_code"
							],
							[
								"silver/payment_type",
								"silver.usp_silver_payment_type"
							]
						]
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_foler_path_usp_name_array')]",
				"[concat(variables('workspaceId'), '/datasets/ds_nyc_taxi_data_dynamic')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/4_1_pl_create_silver_trip_data_green_With Script_Activity')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get Trip Year and Month",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": "use nyc_taxi_ldw\n\nselect DISTINCT year,month from bronze.vw_trip_data_green_csv"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "ForEach Year and Month",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Trip Year and Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Trip Year and Month').output.resultSets[0].rows",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Delete Partition",
									"type": "Delete",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_nyc_taxi_data_dynamic",
											"type": "DatasetReference",
											"parameters": {
												"p_folder_path": {
													"value": "silver/trip_data_green/year=@{item().year}/month=@{item().month}",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										}
									}
								},
								{
									"name": "Create Trip Data Table",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "Delete Partition",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"parameters": [
													{
														"name": "year",
														"type": "String",
														"value": {
															"value": "@item().year",
															"type": "Expression"
														},
														"direction": "Input"
													},
													{
														"name": "month",
														"type": "String",
														"value": {
															"value": "@item().month",
															"type": "Expression"
														},
														"direction": "Input"
													}
												],
												"type": "NonQuery",
												"text": "EXEC silver.usp_silver_trip_data_green @year = @year, @month =@month"
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]",
				"[concat(variables('workspaceId'), '/datasets/ds_nyc_taxi_data_dynamic')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/4_2_pl_create_silver_trip_data_green_With StoredProc_Activity')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get Trip Year and Month",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": "use nyc_taxi_ldw\n\nselect DISTINCT year,month from bronze.vw_trip_data_green_csv"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "ForEach Year and Month",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Trip Year and Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Trip Year and Month').output.resultSets[0].rows",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Delete Partition",
									"type": "Delete",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_nyc_taxi_data_dynamic",
											"type": "DatasetReference",
											"parameters": {
												"p_folder_path": {
													"value": "silver/trip_data_green/year=@{item().year}/month=@{item().month}",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										}
									}
								},
								{
									"name": "Create Partition",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "Delete Partition",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[silver].[usp_silver_trip_data_green]",
										"storedProcedureParameters": {
											"month": {
												"value": {
													"value": "@item().month",
													"type": "Expression"
												},
												"type": "String"
											},
											"year": {
												"value": {
													"value": "@item().year",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					},
					{
						"name": "Create Silver View",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "ForEach Year and Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "NonQuery",
									"text": "USE nyc_taxi_ldw;"
								},
								{
									"type": "Query",
									"text": "DROP VIEW IF EXISTS silver.vw_trip_data_green"
								},
								{
									"type": "Query",
									"text": "\nCREATE VIEW silver.vw_trip_data_green\nAS\n    SELECT\n        \n        --result.filename() as file_name,\n        result.filepath(1) as year, -- 1 here is Position of WildCard  \n        result.filepath(2) as month, -- 2 here is Position of WildCard \n        result.filepath(3) as filename_from_file_path, -- 3 here is Position of WildCard \n        result.*\n    FROM\n        OPENROWSET(\n            BULK '/silver/trip_data_green/year=*/month=*/*.parquet' ,\n            DATA_SOURCE = 'nyc_taxi_src',\n            FORMAT = 'PARQUET'\n        )WITH(\n             vendor_id\tint\n            ,lpep_pickup_datetime\tdatetime2(7)\n            ,lpep_dropoff_datetime\tdatetime2(7)\n            ,store_and_fwd_flag\tCHAR(1)\n            ,rate_code_id\tint\n            ,pu_location_id\tint\n            ,do_location_id\tint\n            ,passenger_count\tint\n            ,trip_distance\tfloat\n            ,fare_amount\tfloat\n            ,extra\tfloat\n            ,mta_tax\tfloat\n            ,tip_amount\tfloat\n            ,tolls_amount\tfloat\n            ,ehail_fee\tint\n            ,improvement_surcharge\tfloat\n            ,total_amount\tfloat\n            ,payment_type\tint\n            ,trip_type\tint\n            ,congestion_surcharge\tfloat\n            ) AS [result] \n        "
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]",
				"[concat(variables('workspaceId'), '/datasets/ds_nyc_taxi_data_dynamic')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/5_pl_create_gold_trip_data_green_With StoredProc_Activity')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get Trip Year and Month",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": "use nyc_taxi_ldw\n\nselect DISTINCT year,month from silver.vw_trip_data_green td\norder by 1,2"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "ForEach Year and Month",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Trip Year and Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Trip Year and Month').output.resultSets[0].rows",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Delete Partition",
									"type": "Delete",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_nyc_taxi_data_dynamic",
											"type": "DatasetReference",
											"parameters": {
												"p_folder_path": {
													"value": "gold/trip_data_green/year=@{item().year}/month=@{item().month}",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										}
									}
								},
								{
									"name": "Create Partition",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "Delete Partition",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "gold.usp_gold_trip_data_green",
										"storedProcedureParameters": {
											"month": {
												"value": {
													"value": "@item().month",
													"type": "Expression"
												},
												"type": "String"
											},
											"year": {
												"value": {
													"value": "@item().year",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					},
					{
						"name": "Create Gold View",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "ForEach Year and Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_serverless_sql_pool_db_nyc_taxi_ldw",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "NonQuery",
									"text": "USE nyc_taxi_ldw;"
								},
								{
									"type": "Query",
									"text": "DROP VIEW IF EXISTS gold.vw_trip_data_green"
								},
								{
									"type": "Query",
									"text": "\nCREATE VIEW gold.vw_trip_data_green\nAS\n    SELECT\n        \n        --result.filename() as file_name,\n        result.filepath(1) as year, -- 1 here is Position of WildCard  \n        result.filepath(2) as month, -- 2 here is Position of WildCard \n        result.filepath(3) as filename_from_file_path, -- 3 here is Position of WildCard \n        result.*\n    FROM\n        OPENROWSET(\n            BULK '/gold/trip_data_green/year=*/month=*/*.parquet' ,\n            DATA_SOURCE = 'nyc_taxi_src',\n            FORMAT = 'PARQUET'\n        )WITH(\n             borough VARCHAR(15),\n             trip_date DATE,\n             trip_day VARCHAR(15),\n             trip_day_weekend_ind CHAR(1),\n             card_trip_count INT,\n             cash_trip_count INT,\n             Street_hail_trip_count INT,\n             Dispatch_hail_trip_count INT,\n             trip_distance FLOAT,\n             trip_duration INT,\n             fare_amount FLOAT\n\n            ) AS [result] \n        "
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_serverless_sql_pool_db_nyc_taxi_ldw')]",
				"[concat(variables('workspaceId'), '/datasets/ds_nyc_taxi_data_dynamic')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/6_pl_spark_create_gold_trip_data_green_agg')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Create Gold Trip Data Green Agg",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "1_spark_create_gold_trip_data_green_agg",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "synpsesparkpool",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Small",
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"driverSize": "Small",
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/1_spark_create_gold_trip_data_green_agg')]",
				"[concat(variables('workspaceId'), '/bigDataPools/synpsesparkpool')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/7_RemoveDuplicateRows')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Remove Duplicates Rows Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "7_Remove_Duplicates_DF",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"EmpSource": {},
									"EmpNewSource": {},
									"WritetoOutputFolder": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/7_Remove_Duplicates_DF')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/82_Cache Sink and Cache Lookup in Mappping DataFlow')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "82_CacheSinkandCacheLookup",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "82_CacheSinkCacheLookup",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"EmployeeSource": {},
									"Employee2": {},
									"countrylookupsource": {},
									"cachedMaxEMPID": {},
									"CachedContryLookup": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice/Azure Data Factory"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/82_CacheSinkCacheLookup')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/8_IncrementKeyFromExistingFile')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Trigger No 8 DataFlow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "8_DF_IncrementKeysFromExistsingSource",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"EmpSourceWithKey": {},
									"EMPSourceWithoutKey": {},
									"WriteToFile": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/8_DF_IncrementKeysFromExistsingSource')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/9_CaclulateRunningTotalByYear')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "DFtoNumber9",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "9_DF_RunningTotal",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"POForRunningTotal": {},
									"WriteToFile": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF Practice"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/dataflows/9_DF_RunningTotal')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PL_10_HourlyDataProcessing')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Wait1",
						"type": "Wait",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF_Practice_2"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PL_10_HourlyLog')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Wait1",
						"type": "Wait",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "ADF_Practice_2"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PL_11_Event_Based_Trigger')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Wait1",
						"type": "Wait",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 5
						}
					},
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Wait1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "vInputParameters",
							"value": {
								"value": "@pipeline().parameters.sourceFileName",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"sourcePath": {
						"type": "string"
					},
					"sourceFileName": {
						"type": "string"
					}
				},
				"variables": {
					"vInputParameters": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF_Practice_2"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RestAPITO_reqres_dot_in')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "RestService1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parPageNo": {
						"type": "int"
					}
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": {
						"value": "/api/users?page=@{dataset().parPageNo}",
						"type": "Expression"
					}
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/RestService1')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_82_employee')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "Output/@{formatDateTime(utcnow(),'yyyy-MM-dd')}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_API_ExcelFile')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_http",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Sample-spreadsheet-file",
					"location": {
						"type": "HttpServerLocation",
						"relativeUrl": "/xls/Sample-Spreadsheet-10-rows.xls"
					},
					"firstRowAsHeader": true
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_http')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_API_XLS')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_http",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "HttpServerLocation",
						"relativeUrl": "xls/Sample-Spreadsheet-10000-rows.xls"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_http')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_AzureSQLDB')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_AzureSQLDB",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "empKey",
						"type": "int",
						"precision": 10
					},
					{
						"name": "Emp_Id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "Emp_Name",
						"type": "varchar"
					},
					{
						"name": "Emp_Gender",
						"type": "varchar"
					},
					{
						"name": "Dept_Id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQLDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_AzureSQLTable')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_AzureSQLDB",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"tableName": {
						"type": "string"
					},
					"schemaName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@dataset().schemaName",
						"type": "Expression"
					},
					"table": {
						"value": "@dataset().tableName",
						"type": "Expression"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQLDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Binary')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parTargetFolderName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "Output/@{dataset().parTargetFolderName}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Binary_Zip')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parTargetFolderName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "Output/@{dataset().parTargetFolderName}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"compression": {
						"type": "ZipDeflate",
						"level": "Fastest"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Employee')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "Employee.txt",
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "EMPID",
						"type": "String"
					},
					{
						"name": "EMPNAME",
						"type": "String"
					},
					{
						"name": "AGE",
						"type": "String"
					},
					{
						"name": "COUNTRY",
						"type": "String"
					},
					{
						"name": "SALARY",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_EmployeeReference')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "EmployeeSchemaReference.txt",
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "EMPID",
						"type": "String"
					},
					{
						"name": "EMPNAME",
						"type": "String"
					},
					{
						"name": "AGE",
						"type": "String"
					},
					{
						"name": "COUNTRY",
						"type": "String"
					},
					{
						"name": "SALARY",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_HTTP_Zip')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_HTTP_FIleExample",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "HttpServerLocation",
						"relativeUrl": "data/dataset/5bd7fcab-e315-42cb-8daf-50b7efc2027e/resource/0ae4d427-6fa8-4d40-8e76-c6909b5a071b/download/public_split_1_10.zip"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_HTTP_FIleExample')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_LogFileDetails')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parFileName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().parFileName",
							"type": "Expression"
						},
						"folderPath": "Output/log/",
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Output_JSON')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parOutputFolder": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "Output/@{dataset().parOutputFolder}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_RESTAPI_xls')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_RESTAPI",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": "/xls/Sample-Spreadsheet-10-rows.xls"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_RESTAPI')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_SQL_Employee')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_AzureSQL_SampleDB",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [],
				"typeProperties": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQL_SampleDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Source_Zip_Binary')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parSourceFolderName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "Output/26_Download_Zip_File_From_API/Staging/@{dataset().parSourceFolderName}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"compression": {
						"type": "ZipDeflate",
						"level": "Fastest"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Target_Binary_Unzipped')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parTargetFolderName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "Output/26_Download_Zip_File_From_API/@{dataset().parTargetFolderName}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_csv')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parFileName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().parFileName",
							"type": "Expression"
						},
						"folderPath": {
							"value": "Output/@{formatDateTime(utcnow(),'yyyy-MM-dd')}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demoOutput')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"prTargetFolderName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "Employee.csv",
						"folderPath": {
							"value": "Output/@{dataset().prTargetFolderName}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo_Dynamic_Folder')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parFolderName": {
						"type": "string"
					},
					"parFileName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Sheet1",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().parFileName",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().parFolderName",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"type": "String"
					},
					{
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo_Output_Directoty_N_File')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parTargetFolderName": {
						"type": "string"
					},
					"parTargetFileName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().parTargetFileName",
							"type": "Expression"
						},
						"folderPath": {
							"value": "Output/@{dataset().parTargetFolderName}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "id",
						"type": "String"
					},
					{
						"name": "email",
						"type": "String"
					},
					{
						"name": "first_name",
						"type": "String"
					},
					{
						"name": "last_name",
						"type": "String"
					},
					{
						"name": "avatar",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo_file')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parFileName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().parFileName",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo_file_details')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parFileName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().parFileName",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo_input_directory_file')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parFolderName": {
						"type": "string",
						"defaultValue": "24_Split_Single_Row_into_Multiple"
					},
					"parFileName": {
						"type": "string",
						"defaultValue": "EnglandCrickterSkills.csv"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().parFileName",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().parFolderName",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Name",
						"type": "String"
					},
					{
						"name": "Age",
						"type": "String"
					},
					{
						"name": "Skill",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo_output_directory')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parTarget": {
						"type": "string",
						"defaultValue": "24_Split_Single_Row_into_Multiple"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "Output/@{dataset().parTarget}/@{formatDateTime(utcnow(),'yyyy-MM-dd HH:mm:ss')}",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_demo_source_folder')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parFolderName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@dataset().parFolderName",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_foler_path_usp_name_array')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "foler_path_usp_name_array.json",
						"folderPath": "silver",
						"fileSystem": "nyc-taxi-data"
					}
				},
				"schema": {
					"type": "object",
					"properties": {
						"folder_path": {
							"type": "string"
						},
						"usp_name": {
							"type": "string"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_nyc_taxi_data_dynamic')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"p_folder_path": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@dataset().p_folder_path",
							"type": "Expression"
						},
						"fileSystem": "nyc-taxi-data"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_silver_taxi_zone')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "silver/taxi_zone",
						"fileSystem": "nyc-taxi-data"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_target')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_azuresynapsecoursedl",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"parTargetFolderName": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@dataset().parTargetFolderName",
							"type": "Expression"
						},
						"fileSystem": "demo"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RestService1')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('RestService1_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/bing-covid-19-data')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"sasUri": "[parameters('bing-covid-19-data_sasUri')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_AzureSQLDB')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDatabase",
				"typeProperties": {
					"connectionString": "[parameters('ls_AzureSQLDB_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_AzureSQL_SampleDB')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDatabase",
				"typeProperties": {
					"connectionString": "[parameters('ls_AzureSQL_SampleDB_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_HTTP_FIleExample')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "HttpServer",
				"typeProperties": {
					"url": "[parameters('ls_HTTP_FIleExample_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_RESTAPI')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('ls_RESTAPI_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_azuresynapsecoursedl')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('ls_azuresynapsecoursedl_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_cosmos_nyc_taxi_data')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "CosmosDb",
				"typeProperties": {
					"connectionString": "[parameters('ls_cosmos_nyc_taxi_data_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_http')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "HttpServer",
				"typeProperties": {
					"url": "[parameters('ls_http_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_power_bi_synapse_integration_ws')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "PowerBIWorkspace",
				"typeProperties": {
					"workspaceID": "a28121ca-cb2b-4ea9-89ad-b5e6d9c7d59d",
					"tenantID": "7a9a2b90-a731-4800-a4f0-46ddb6f7d715"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_serverless_sql_pool_db_nyc_taxi_ldw')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"connectionString": "[parameters('ls_serverless_sql_pool_db_nyc_taxi_ldw_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/synapse-course-workspace-WorkspaceDefaultSqlServer')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"DBName": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"connectionString": "[parameters('synapse-course-workspace-WorkspaceDefaultSqlServer_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/synapse-course-workspace-WorkspaceDefaultStorage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('synapse-course-workspace-WorkspaceDefaultStorage_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Evetn Trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "PL_11_Event_Based_Trigger",
							"type": "PipelineReference"
						},
						"parameters": {
							"sourcePath": "[parameters('Evetn Trigger_properties_PL_11_Event_Based_Trigger_parameters_sourcePath')]",
							"sourceFileName": "[parameters('Evetn Trigger_properties_PL_11_Event_Based_Trigger_parameters_sourceFileName')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/practice/blobs/input / S_11_Event_Based_Trigger/",
					"blobPathEndsWith": ".txt",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('Evetn Trigger_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/PL_11_Event_Based_Trigger')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HourlyDataProcessingTrigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipeline": {
					"pipelineReference": {
						"referenceName": "PL_10_HourlyDataProcessing",
						"type": "PipelineReference"
					},
					"parameters": {}
				},
				"type": "TumblingWindowTrigger",
				"typeProperties": {
					"frequency": "Minute",
					"interval": 15,
					"startTime": "2023-10-17T09:00:00Z",
					"endTime": "2023-10-25T03:20:00Z",
					"delay": "00:00:00",
					"maxConcurrency": 50,
					"retryPolicy": {
						"intervalInSeconds": 30
					},
					"dependsOn": [
						{
							"type": "TumblingWindowTriggerDependencyReference",
							"offset": "0.00:00:00",
							"referenceTrigger": {
								"referenceName": "HourlyLogsTrigger",
								"type": "TriggerReference"
							}
						},
						{
							"type": "SelfDependencyTumblingWindowTriggerReference",
							"offset": "-1.00:00:00"
						}
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/PL_10_HourlyDataProcessing')]",
				"[concat(variables('workspaceId'), '/triggers/HourlyLogsTrigger')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HourlyLogsTrigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipeline": {
					"pipelineReference": {
						"referenceName": "PL_10_HourlyLog",
						"type": "PipelineReference"
					},
					"parameters": {}
				},
				"type": "TumblingWindowTrigger",
				"typeProperties": {
					"frequency": "Minute",
					"interval": 15,
					"startTime": "2023-10-16T09:00:00Z",
					"endTime": "2023-10-25T03:19:00Z",
					"delay": "00:00:00",
					"maxConcurrency": 50,
					"retryPolicy": {
						"intervalInSeconds": 30
					},
					"dependsOn": []
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/PL_10_HourlyLog')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutoResolveIntegrationRuntime')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 0
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/10_DF_LogFile_Append')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "This DataFlow Task will Append Data to LogFIle for logging purpose . Video No 10 .",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "SampleFileSource",
							"description": "Connecting to Sample File \"demo/SampleOneValue.csv\" which has one dummy row ."
						},
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "LogFileSource"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "AppendAlltheRequredColumnsForLogging",
							"description": "Add the Columns for Logging Purpose"
						},
						{
							"name": "RemoveTheDummyColumnFromTheSource",
							"description": "Remove The Dummy Column Which is coming from the Source"
						},
						{
							"name": "CombineWithLogFileSource"
						}
					],
					"scriptLines": [
						"parameters{",
						"     ADFName as string,",
						"     PipeLineName as string,",
						"     Status as string,",
						"     RunId as string,",
						"     TriggerName as string,",
						"     ExecutedOn as string,",
						"     FileName as string",
						"}",
						"source(output(",
						"          {_col0_} as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'SampleOneValue.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: false) ~> SampleFileSource",
						"source(useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: 'Output/log',",
						"     fileName: ($FileName),",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> LogFileSource",
						"SampleFileSource derive(ADFName = $ADFName,",
						"          PipelineName = $PipeLineName,",
						"          Status = $Status,",
						"          RunId = $RunId,",
						"          TriggerName = $TriggerName,",
						"          ExecutedOn = $ExecutedOn) ~> AppendAlltheRequredColumnsForLogging",
						"AppendAlltheRequredColumnsForLogging select(mapColumn(",
						"          ADFName,",
						"          PipelineName,",
						"          Status,",
						"          RunId,",
						"          TriggerName,",
						"          ExecutedOn",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RemoveTheDummyColumnFromTheSource",
						"RemoveTheDummyColumnFromTheSource, LogFileSource union(byName: true)~> CombineWithLogFileSource",
						"CombineWithLogFileSource sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: 'Output/log',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:[($FileName)],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/10_DF_LogFile_Create')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "This DataFlow Task will create a LogFIle for logging purpose . Video No 10 .",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "SampleFileSource",
							"description": "Connecting to Sample File \"demo/SampleOneValue.csv\" which has one dummy row ."
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "WriteToLogFile",
							"description": "Write to the log file"
						}
					],
					"transformations": [
						{
							"name": "AppendAlltheRequredColumnsForLogging",
							"description": "Add the Columns for Logging Purpose"
						},
						{
							"name": "RemoveTheDummyColumnFromTheSource",
							"description": "Remove The Dummy Column Which is coming from the Source"
						}
					],
					"scriptLines": [
						"parameters{",
						"     ADFName as string,",
						"     PipeLineName as string,",
						"     Status as string,",
						"     RunId as string,",
						"     TriggerName as string,",
						"     ExecutedOn as string,",
						"     FileName as string",
						"}",
						"source(output(",
						"          {_col0_} as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'SampleOneValue.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: false) ~> SampleFileSource",
						"SampleFileSource derive(ADFName = $ADFName,",
						"          PipelineName = $PipeLineName,",
						"          Status = $Status,",
						"          RunId = $RunId,",
						"          TriggerName = $TriggerName,",
						"          ExecutedOn = $ExecutedOn) ~> AppendAlltheRequredColumnsForLogging",
						"AppendAlltheRequredColumnsForLogging select(mapColumn(",
						"          ADFName,",
						"          PipelineName,",
						"          Status,",
						"          RunId,",
						"          TriggerName,",
						"          ExecutedOn",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RemoveTheDummyColumnFromTheSource",
						"RemoveTheDummyColumnFromTheSource sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: 'Output/log/',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:[($FileName)],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> WriteToLogFile"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/11_DF_SCDType1')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "SourceToEmployee",
							"description": "Connet to \"demo/Employee.txt\""
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_AzureSQLDB",
								"type": "LinkedServiceReference"
							},
							"name": "WriteToDB",
							"description": "Write to \"azuresynapsesqlsrv /synapsedev / dbo.Employee\""
						}
					],
					"transformations": [
						{
							"name": "AlterTheRows",
							"description": "Alter the Rows to allow UPsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EMPID as integer,",
						"          EMPNAME as string,",
						"          AGE as integer,",
						"          COUNTRY as string,",
						"          SALARY as integer",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'Employee.txt',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> SourceToEmployee",
						"SourceToEmployee alterRow(upsertIf(true())) ~> AlterTheRows",
						"AlterTheRows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: 'dbo',",
						"     tableName: 'EMPLOYEE',",
						"     insertable: false,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: true,",
						"     keys:['EMPID'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> WriteToDB"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQLDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/17_DF_SCDType2')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EmployeeFile"
						},
						{
							"linkedService": {
								"referenceName": "ls_AzureSQLDB",
								"type": "LinkedServiceReference"
							},
							"name": "employeeTable"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_AzureSQLDB",
								"type": "LinkedServiceReference"
							},
							"name": "sinkToInsertOnly"
						},
						{
							"linkedService": {
								"referenceName": "ls_AzureSQLDB",
								"type": "LinkedServiceReference"
							},
							"name": "sink2Update"
						}
					],
					"transformations": [
						{
							"name": "addIsActiveColumn"
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "filterUnMatchedRows"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'EmployeeFileForSCD2.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EmployeeFile",
						"source(output(",
						"          empKey as integer,",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer,",
						"          isActive as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: 'dbo',",
						"     tableName: 'Employee',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> employeeTable",
						"EmployeeFile derive(isActive = 1) ~> addIsActiveColumn",
						"employeeTable select(mapColumn(",
						"          SQL_empKey = empKey,",
						"          SQL_empid = empid,",
						"          SQL_empname = empname,",
						"          SQL_gender = gender,",
						"          SQL_country = country,",
						"          SQL_salary = salary,",
						"          SQL_isActive = isActive",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"EmployeeFile, select1 lookup(empid == SQL_empid,",
						"     multiple: true,",
						"     broadcast: 'auto',",
						"     pickup: 'any')~> lookup1",
						"lookup1 filter(!isNull(SQL_empid)) ~> filterUnMatchedRows",
						"filterUnMatchedRows select(mapColumn(",
						"          SQL_empKey,",
						"          SQL_empid,",
						"          SQL_empname,",
						"          SQL_gender,",
						"          SQL_country,",
						"          SQL_salary,",
						"          SQL_isActive",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 derive(SQL_isActive = 0) ~> derivedColumn1",
						"derivedColumn1 alterRow(updateIf(1==1)) ~> alterRow1",
						"addIsActiveColumn sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          empKey as integer,",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer,",
						"          isActive as integer",
						"     ),",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: 'dbo',",
						"     tableName: 'Employee',",
						"     insertable: true,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          empid,",
						"          empname,",
						"          gender,",
						"          country,",
						"          salary,",
						"          isActive",
						"     )) ~> sinkToInsertOnly",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          empKey as integer,",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer,",
						"          isActive as integer",
						"     ),",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: 'dbo',",
						"     tableName: 'Employee',",
						"     insertable: false,",
						"     updateable: true,",
						"     deletable: false,",
						"     upsertable: false,",
						"     keys:['empid'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          empid = SQL_empid,",
						"          empname = SQL_empname,",
						"          gender = SQL_gender,",
						"          country = SQL_country,",
						"          salary = SQL_salary,",
						"          isActive = SQL_isActive",
						"     )) ~> sink2Update"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQLDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/17_DF_SCDType2_ModifiedDate')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EmployeeFile"
						},
						{
							"linkedService": {
								"referenceName": "ls_AzureSQLDB",
								"type": "LinkedServiceReference"
							},
							"name": "employeeTable"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_AzureSQLDB",
								"type": "LinkedServiceReference"
							},
							"name": "sinkToInsertOnly"
						},
						{
							"linkedService": {
								"referenceName": "ls_AzureSQLDB",
								"type": "LinkedServiceReference"
							},
							"name": "sink2Update"
						}
					],
					"transformations": [
						{
							"name": "addIsActiveColumn"
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "filterUnMatchedRows"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'EmployeeFileForSCD2.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EmployeeFile",
						"source(output(",
						"          empKey as integer,",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer,",
						"          isActive as integer,",
						"          startDate as timestamp,",
						"          endDate as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: 'dbo',",
						"     tableName: 'Employee',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> employeeTable",
						"EmployeeFile derive(isActive = 1,",
						"          startDate = currentTimestamp()) ~> addIsActiveColumn",
						"employeeTable select(mapColumn(",
						"          SQL_empKey = empKey,",
						"          SQL_empid = empid,",
						"          SQL_empname = empname,",
						"          SQL_gender = gender,",
						"          SQL_country = country,",
						"          SQL_salary = salary,",
						"          SQL_isActive = isActive,",
						"          SQL_endDate = endDate",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"EmployeeFile, select1 lookup(empid == SQL_empid,",
						"     multiple: true,",
						"     broadcast: 'auto',",
						"     pickup: 'any')~> lookup1",
						"lookup1 filter(!isNull(SQL_empid)  && isNull(SQL_endDate)) ~> filterUnMatchedRows",
						"filterUnMatchedRows select(mapColumn(",
						"          SQL_empKey,",
						"          SQL_empid,",
						"          SQL_empname,",
						"          SQL_gender,",
						"          SQL_country,",
						"          SQL_salary,",
						"          SQL_isActive,",
						"          SQL_endDate",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 derive(SQL_isActive = 0,",
						"          SQL_endDate = currentTimestamp()) ~> derivedColumn1",
						"derivedColumn1 alterRow(updateIf(1==1)) ~> alterRow1",
						"addIsActiveColumn sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          empKey as integer,",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer,",
						"          isActive as integer,",
						"          startDate as timestamp,",
						"          endDate as timestamp",
						"     ),",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: 'dbo',",
						"     tableName: 'Employee',",
						"     insertable: true,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          empid,",
						"          empname,",
						"          gender,",
						"          country,",
						"          salary,",
						"          isActive,",
						"          startDate",
						"     )) ~> sinkToInsertOnly",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          empKey as integer,",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer,",
						"          isActive as integer,",
						"          startDate as timestamp,",
						"          endDate as timestamp",
						"     ),",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: 'dbo',",
						"     tableName: 'Employee',",
						"     insertable: false,",
						"     updateable: true,",
						"     deletable: false,",
						"     upsertable: false,",
						"     keys:['empKey'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          empKey = SQL_empKey,",
						"          empid = SQL_empid,",
						"          empname = SQL_empname,",
						"          gender = SQL_gender,",
						"          country = SQL_country,",
						"          salary = SQL_salary,",
						"          isActive = SQL_isActive,",
						"          endDate = SQL_endDate",
						"     )) ~> sink2Update"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_AzureSQLDB')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/22_MergeMultipleRows_into_SingleRow')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EnglandCricktersCSV"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "WriteToFolder"
						}
					],
					"transformations": [
						{
							"name": "selectRequiredColumns"
						},
						{
							"name": "GroupByHeader"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Header as string,",
						"          Name as string,",
						"          Age as short,",
						"          {Batting style} as string,",
						"          {Bowling style} as string,",
						"          {Domestic team} as string,",
						"          {C/T} as string,",
						"          Forms as string,",
						"          {S/N} as short,",
						"          Captaincy as string,",
						"          {Last Test} as string,",
						"          {Last ODI} as string,",
						"          {Last T20I} as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '22_Merge_MultipleRows_Into_Single',",
						"     fileName: 'England Cricket Team.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EnglandCricktersCSV",
						"EnglandCricktersCSV select(mapColumn(",
						"          each(match(name==\"Header\"||name==\"Name\"||name==\"Age\"||name==\"Batting style\"))",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredColumns",
						"selectRequiredColumns aggregate(groupBy(Header),",
						"     Properties = replace(replace(replace(toString(collect(concat('(',Name,',',toString(Age),',',{Batting style},')')\r",
						")) , '\"', \"\") ,'[',''),']','')) ~> GroupByHeader",
						"GroupByHeader sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: (concat(\"Output/\",toString(currentDate(), \"yyyy-MM-dd\"),\"/22_Merge_MultipleRows_Into_Single/\")),",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:['EnglandCricketsProperties.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> WriteToFolder"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/7_Remove_Duplicates_DF')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EmpSource",
							"description": "Employee Dataset Source"
						},
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EmpNewSource"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "WritetoOutputFolder",
							"description": "Write to Output/UniqueEmpoyees Folder"
						}
					],
					"transformations": [
						{
							"name": "UnionEmpSrcAndEmpNewSrc",
							"description": "Combining rows from transformation EmpSource and EmpNewSource"
						},
						{
							"name": "RemoveDuplicates",
							"description": "Remove Duplicates based on EMPID Column and keep First Row as unique Row."
						}
					],
					"scriptLines": [
						"source(output(",
						"          EMPID as string,",
						"          EMPNAME as string,",
						"          AGE as string,",
						"          COUNTRY as string,",
						"          SALARY as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'Employee.txt',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EmpSource",
						"source(output(",
						"          EMPID as string,",
						"          EMPNAME as string,",
						"          AGE as string,",
						"          COUNTRY as string,",
						"          SALARY as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'EmployeeNew.txt',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EmpNewSource",
						"EmpSource, EmpNewSource union(byName: true)~> UnionEmpSrcAndEmpNewSrc",
						"UnionEmpSrcAndEmpNewSrc aggregate(groupBy(EMPID),",
						"     each(match(name!=\"EMPID\"), $$ = first($$))) ~> RemoveDuplicates",
						"RemoveDuplicates sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: 'Output/UniqueEmpoyees',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:['EmployeeUnique.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> WritetoOutputFolder"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/82_CacheSinkCacheLookup')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EmployeeSource",
							"description": "Connect to \" Employee1.csv\" to gent the Max EMP ID"
						},
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "Employee2"
						},
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "countrylookupsource"
						}
					],
					"sinks": [
						{
							"name": "cachedMaxEMPID"
						},
						{
							"name": "CachedContryLookup"
						},
						{
							"dataset": {
								"referenceName": "ds_82_employee",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "GetMaxEMPID"
						},
						{
							"name": "selectcolumns"
						},
						{
							"name": "GenerateSurrogateKey"
						},
						{
							"name": "GenerateNewValueforEMPID"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          empid as integer,",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'Employee1.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EmployeeSource",
						"source(output(",
						"          empname as string,",
						"          gender as string,",
						"          country as string,",
						"          salary as integer",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'Employee2.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> Employee2",
						"source(output(",
						"          {country_code } as string,",
						"          country_name as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'ContryLookup.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> countrylookupsource",
						"EmployeeSource aggregate(groupBy(GETDATE = currentUTC()),",
						"     maxEmpID = max(empid)) ~> GetMaxEMPID",
						"GetMaxEMPID select(mapColumn(",
						"          maxEmpID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcolumns",
						"Employee2 keyGenerate(output(new_col_emp_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> GenerateSurrogateKey",
						"GenerateSurrogateKey derive(emp_id = cachedMaxEMPID#outputs()[1].maxEmpID + new_col_emp_id,",
						"          country = CachedContryLookup#lookup(country).country_name) ~> GenerateNewValueforEMPID",
						"GenerateNewValueforEMPID select(mapColumn(",
						"          empname,",
						"          gender,",
						"          country,",
						"          salary,",
						"          emp_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"selectcolumns sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 0,",
						"     mapColumn(",
						"          maxEmpID",
						"     )) ~> cachedMaxEMPID",
						"countrylookupsource sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     keys:['country_code '],",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 0,",
						"     mapColumn(",
						"          {country_code },",
						"          country_name",
						"     )) ~> CachedContryLookup",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]",
				"[concat(variables('workspaceId'), '/datasets/ds_82_employee')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/8_DF_IncrementKeysFromExistsingSource')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EmpSourceWithKey",
							"description": "Emp File with EMPID "
						},
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EMPSourceWithoutKey",
							"description": "Connect to EmployeeWithNoKey.txt"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "WriteToFile",
							"description": "Write to Output/IncrementKeyEmpoyees"
						}
					],
					"transformations": [
						{
							"name": "GetMaxID",
							"description": "Get MAX ID"
						},
						{
							"name": "CrossJoinWithEmpSource"
						},
						{
							"name": "GenerateKeyValue",
							"description": "Generate Key Value For Each Row"
						},
						{
							"name": "GenerateNewID",
							"description": "Add MAX ID with SurrogateKey Value"
						},
						{
							"name": "unionEmployees"
						},
						{
							"name": "selectRequiredColumns",
							"description": "Select Required Columns and remove unwanted columns"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EMPID as string,",
						"          EMPNAME as string,",
						"          AGE as string,",
						"          COUNTRY as string,",
						"          SALARY as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'Employee.txt',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EmpSourceWithKey",
						"source(output(",
						"          EMPNAME as string,",
						"          AGE as string,",
						"          COUNTRY as string,",
						"          SALARY as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'EmployeeWithNoKey.txt',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> EMPSourceWithoutKey",
						"EmpSourceWithKey aggregate(groupBy(DUMMYDATE = currentUTC()),",
						"     MAXID = max(EMPID)) ~> GetMaxID",
						"GetMaxID, EMPSourceWithoutKey join(true(),",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> CrossJoinWithEmpSource",
						"CrossJoinWithEmpSource keyGenerate(output(EMPID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> GenerateKeyValue",
						"GenerateKeyValue derive(EMPID = toString(toInteger(MAXID) + toInteger(EMPID))) ~> GenerateNewID",
						"GenerateNewID, EmpSourceWithKey union(byName: true)~> unionEmployees",
						"unionEmployees select(mapColumn(",
						"          EMPID,",
						"          EMPNAME,",
						"          AGE,",
						"          COUNTRY,",
						"          SALARY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredColumns",
						"selectRequiredColumns sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: 'Output/IncrementKeyEmpoyees',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:['AllEmployees.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> WriteToFile"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/9_DF_RunningTotal')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "POForRunningTotal",
							"description": "Connect to File \"demo/POForRunningTotal.csv\""
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "WriteToFile",
							"description": "Write to \"demo / Output/RunningTotalByYear\""
						}
					],
					"transformations": [
						{
							"name": "WindowForRunningTotal",
							"description": "Calculate Running Total By Year"
						}
					],
					"scriptLines": [
						"source(output(",
						"          PO as string,",
						"          ItemName as string,",
						"          Year as string,",
						"          Quantity as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     fileName: 'POForRunningTotal.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> POForRunningTotal",
						"POForRunningTotal window(over(Year),",
						"     asc(Quantity, true),",
						"     RunningTotal = sum(toInteger(Quantity))) ~> WindowForRunningTotal",
						"WindowForRunningTotal sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: 'Output/RunningTotalByYear',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:['RunningTotalByYearSortByQty.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> WriteToFile"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DF_24_Split_SingleRowsInto_Multiple')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_demo_input_directory_file",
								"type": "DatasetReference"
							},
							"name": "SourceToEnglandCricketersSkills"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_demo_output_directory",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "ConvertSkillColumntoArray"
						},
						{
							"name": "FlattenArrayColumn"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Name as string,",
						"          Age as string,",
						"          Skill as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> SourceToEnglandCricketersSkills",
						"SourceToEnglandCricketersSkills derive(SkillArray = split(Skill,\",\")) ~> ConvertSkillColumntoArray",
						"ConvertSkillColumntoArray foldDown(unroll(SkillArray),",
						"     mapColumn(",
						"          Name,",
						"          Age,",
						"          Skill,",
						"          SkillType = SkillArray",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> FlattenArrayColumn",
						"FlattenArrayColumn sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          Name,",
						"          Age,",
						"          Skill,",
						"          SkillType",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_demo_input_directory_file')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_output_directory')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DF_28_TimeZone_Conversion_In_MDF')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Using this MDF , we will convert UTC Time to IST Time .",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "EnglanCricktersEntryTime"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_demo_output_directory",
								"type": "DatasetReference"
							},
							"name": "writeToFolder"
						}
					],
					"transformations": [
						{
							"name": "ConvertEntryDatetoIST"
						}
					],
					"scriptLines": [
						"parameters{",
						"     parFolderName as string ('28_TimeZone_Conversion_in_MDF'),",
						"     parFileName as string ('EnglandCricketersEntryTiing.csv')",
						"}",
						"source(output(",
						"          Name as string,",
						"          Age as short,",
						"          EntryDate as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: ($parFolderName),",
						"     fileName: ($parFileName),",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     multiLineRow: true) ~> EnglanCricktersEntryTime",
						"EnglanCricktersEntryTime derive(EntryDateTime_IST = fromUTC(toTimestamp(EntryDate,'yyyy-MM-dd HH:mm:ss'),'IST')) ~> ConvertEntryDatetoIST",
						"ConvertEntryDatetoIST sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          Name,",
						"          Age,",
						"          EntryDate,",
						"          EntryDateTime_IST",
						"     )) ~> writeToFolder"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]",
				"[concat(variables('workspaceId'), '/datasets/ds_demo_output_directory')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DF_33_2_Load_CSV_into_JSON')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "CustomerPurchases"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          CustId as integer,",
						"          CustName as string,",
						"          ItemName as string,",
						"          Quantity as integer",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '33_Load_CSV_into_JSON',",
						"     fileName: 'CustomerPurchases.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> CustomerPurchases",
						"CustomerPurchases aggregate(groupBy(CustId,",
						"          CustName),",
						"     Purchases = collect(@(itemName =ItemName , quantity = Quantity) )) ~> aggregate1",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'json',",
						"     fileSystem: 'demo',",
						"     folderPath: (concat('Output','/','33_Load_CSV_into_JSON')),",
						"     truncate: true,",
						"     partitionFileNames:['CustomerPurchases.json'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DF_33_3_Load_CSV_into_JSON')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "CustomerPurchases",
							"description": "Connect to Customer Purchases File"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "Purchases",
							"description": "Create SubColumns here"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "sort1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          CustId as integer,",
						"          CustName as string,",
						"          ItemName as string,",
						"          Quantity as integer",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '33_Load_CSV_into_JSON',",
						"     fileName: 'CustomerPurchases.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> CustomerPurchases",
						"CustomerPurchases derive(Purchases = @(ItemName=ItemName,",
						"          Quantity=Quantity)) ~> Purchases",
						"Purchases aggregate(groupBy(CustId,",
						"          CustName),",
						"     Purchases = collect(Purchases)) ~> aggregate1",
						"aggregate1 sort(asc(CustId, true)) ~> sort1",
						"sort1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'json',",
						"     fileSystem: 'demo',",
						"     folderPath: (concat('Output','/','33_Load_CSV_into_JSON')),",
						"     truncate: true,",
						"     partitionFileNames:['CustomerPurchases.json'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DF_35_1_Compare_Source_Target_MDF')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "SourceData"
						},
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "DataToCompareWith"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "WritetoFile"
						}
					],
					"transformations": [
						{
							"name": "GenerateHashColumn"
						},
						{
							"name": "GenerateHasForTarget"
						},
						{
							"name": "SelectSourceColumns"
						},
						{
							"name": "SelectTargetColumns"
						},
						{
							"name": "DoexNotExists"
						}
					],
					"scriptLines": [
						"parameters{",
						"     parTargetFolder as string (\"35_Compare_Source_Target_MDF\")",
						"}",
						"source(output(",
						"          Header as string,",
						"          Name as string,",
						"          Age as short,",
						"          {Batting style} as string,",
						"          {Bowling style} as string,",
						"          {Domestic team} as string,",
						"          {C/T} as string,",
						"          Forms as string,",
						"          {S/N} as short,",
						"          Captaincy as string,",
						"          {Last Test} as short,",
						"          {Last ODI} as string,",
						"          {Last T20I} as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '35_Compare_Source_Target_MDF',",
						"     fileName: 'SourceData.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> SourceData",
						"source(output(",
						"          Header as string,",
						"          Name as string,",
						"          Age as short,",
						"          {Batting style} as string,",
						"          {Bowling style} as string,",
						"          {Domestic team} as string,",
						"          {C/T} as string,",
						"          Forms as string,",
						"          {S/N} as short,",
						"          Captaincy as string,",
						"          {Last Test} as string,",
						"          {Last ODI} as string,",
						"          {Last T20I} as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '35_Compare_Source_Target_MDF',",
						"     fileName: 'CompareWith.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> DataToCompareWith",
						"SelectSourceColumns derive(HashValueSource = sha2(256,columns())) ~> GenerateHashColumn",
						"SelectTargetColumns derive(HashValueTarget = sha2(256,columns())) ~> GenerateHasForTarget",
						"SourceData select(mapColumn(",
						"          Header,",
						"          Name,",
						"          Age,",
						"          {Batting style},",
						"          {Bowling style}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectSourceColumns",
						"DataToCompareWith select(mapColumn(",
						"          Header,",
						"          Name,",
						"          Age,",
						"          {Batting style},",
						"          {Bowling style}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectTargetColumns",
						"GenerateHashColumn, GenerateHasForTarget exists(HashValueSource == HashValueTarget,",
						"     negate:true,",
						"     broadcast: 'auto')~> DoexNotExists",
						"DoexNotExists sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: (concat('Output/',$parTargetFolder)),",
						"     truncate: true,",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:['NonMatchingCrickters'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> WritetoFile"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DF_35_2_Compare_Source_Target_MDF')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "SourceData"
						},
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "DataToCompareWith"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "WriteToFile"
						}
					],
					"transformations": [
						{
							"name": "GenerateHashColumn"
						},
						{
							"name": "GenerateHasForTarget"
						},
						{
							"name": "SelectSourceColumns"
						},
						{
							"name": "SelectTargetColumns"
						},
						{
							"name": "joinWithTarget"
						},
						{
							"name": "KeepOnlyNewClicketers"
						},
						{
							"name": "KeepOnlySourceColumns"
						},
						{
							"name": "RenameColumns"
						}
					],
					"scriptLines": [
						"parameters{",
						"     parTargetFolder as string (\"35_Compare_Source_Target_MDF\")",
						"}",
						"source(output(",
						"          Header as string,",
						"          Name as string,",
						"          Age as short,",
						"          {Batting style} as string,",
						"          {Bowling style} as string,",
						"          {Domestic team} as string,",
						"          {C/T} as string,",
						"          Forms as string,",
						"          {S/N} as short,",
						"          Captaincy as string,",
						"          {Last Test} as string,",
						"          {Last ODI} as string,",
						"          {Last T20I} as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '35_Compare_Source_Target_MDF',",
						"     fileName: 'SourceData.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> SourceData",
						"source(output(",
						"          Header as string,",
						"          Name as string,",
						"          Age as short,",
						"          {Batting style} as string,",
						"          {Bowling style} as string,",
						"          {Domestic team} as string,",
						"          {C/T} as string,",
						"          Forms as string,",
						"          {S/N} as short,",
						"          Captaincy as string,",
						"          {Last Test} as short,",
						"          {Last ODI} as string,",
						"          {Last T20I} as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '35_Compare_Source_Target_MDF',",
						"     fileName: 'CompareWith.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> DataToCompareWith",
						"SelectSourceColumns derive(HashValueSource = sha2(256,Header,Name,Age,{Batting style})) ~> GenerateHashColumn",
						"SelectTargetColumns derive(HashValueTarget = sha2(256,Header,Name,Age,{Batting style})) ~> GenerateHasForTarget",
						"SourceData select(mapColumn(",
						"          Header,",
						"          Name,",
						"          Age,",
						"          {Batting style},",
						"          {Bowling style}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectSourceColumns",
						"DataToCompareWith select(mapColumn(",
						"          Header,",
						"          Name,",
						"          Age,",
						"          {Batting style},",
						"          {Bowling style}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectTargetColumns",
						"GenerateHashColumn, GenerateHasForTarget join(HashValueSource == HashValueTarget,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinWithTarget",
						"RenameColumns filter(isNull(Target_HashValue)) ~> KeepOnlyNewClicketers",
						"KeepOnlyNewClicketers select(mapColumn(",
						"          each(match(startsWith(name,'Source')),",
						"               replace($0,'Source_','') = $$)",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: true) ~> KeepOnlySourceColumns",
						"joinWithTarget select(mapColumn(",
						"          Source_Header = SelectSourceColumns@Header,",
						"          Source_Name = SelectSourceColumns@Name,",
						"          Source_Age = SelectSourceColumns@Age,",
						"          {Source_Batting style} = SelectSourceColumns@{Batting style},",
						"          {Source_Bowling style} = SelectSourceColumns@{Bowling style},",
						"          Source_HashValue = HashValueSource,",
						"          Target_Header = SelectTargetColumns@Header,",
						"          Target_Name = SelectTargetColumns@Name,",
						"          Target_Age = SelectTargetColumns@Age,",
						"          {Target_Batting style} = SelectTargetColumns@{Batting style},",
						"          {Target_Bowling style} = SelectTargetColumns@{Bowling style},",
						"          Target_HashValue = HashValueTarget",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: false) ~> RenameColumns",
						"KeepOnlySourceColumns sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: (concatWS('/', 'Output', $parTargetFolder)),",
						"     truncate: true,",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:['NewCricketers.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> WriteToFile"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DF_Convert_TablularData_To_NestedJson')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "AzureContent"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "aggregate1"
						},
						{
							"name": "cast1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as short,",
						"          name as string,",
						"          type as string,",
						"          value as string",
						"     ),",
						"     useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '35_ByAnnu_ConvertTablularDatatoNestedJson',",
						"     fileName: 'ConvertTablularDatatoNestedJson.csv',",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> source1",
						"source1 aggregate(groupBy(id,",
						"          name),",
						"     typeData = keyValues(collect(byName(\"type\")),collect(byName(\"value\")))) ~> aggregate1",
						"aggregate1 cast(output(",
						"          id as string",
						"     ),",
						"     errors: true) ~> cast1",
						"cast1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'json',",
						"     fileSystem: 'demo',",
						"     folderPath: 'Output/35_ByAnnu_ConvertTablularDatatoNestedJson',",
						"     truncate: true,",
						"     partitionFileNames:['ConvertedtoJson.json'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Dataflow1')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "employeefile"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "ls_azuresynapsecoursedl",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     parFileName as string (\"EmployeeSkills.csv\"),",
						"     parRule as string (toString(byName('gender')=='male'))",
						"}",
						"source(useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: '34_Dynamic_Pass_Expression_into_MDF',",
						"     fileName: ($parFileName),",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true) ~> employeefile",
						"employeefile filter(toBoolean(expr($parRule))) ~> filter1",
						"filter1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'demo',",
						"     folderPath: (concat('Output','/34_Dynamic_Pass_Expression_into_MDF')),",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:['EmployeeSkills.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_azuresynapsecoursedl')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/WorkspaceSystemIdentity')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ManagedIdentity",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/10_Check_For_Duplicates')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "USE nyc_taxi_discovery\nGO\n--------------------------------------\n-- Duplicate location_id\n--------------------------------------\nSELECT\n    location_id , COUNT(1) AS number_of_records\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIRSTROW = 2 ,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (location_id SMALLINT 1,\n    borough VARCHAR(15)  2 ,\n    zone VARCHAR(50)  3 ,\n    service_zone VARCHAR(15) 4  \n    )AS [result]\n    GROUP BY location_id\n    HAVING COUNT(1) > 1\n\n--------------------------------------\n-- Duplicate borough\n--------------------------------------\n   SELECT\n    borough , COUNT(1) AS number_of_records\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIRSTROW = 2 ,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (location_id SMALLINT 1,\n    borough VARCHAR(15)  2 ,\n    zone VARCHAR(50)  3 ,\n    service_zone VARCHAR(15) 4  \n    )AS [result]\n    GROUP BY borough\n    HAVING COUNT(1) > 1 ",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/10_Create_Silver_Rate_Code_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.vendor using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.rate_code') IS NOT NULL\n    DROP EXTERNAL TABLE silver.rate_code\nGO\n\nCREATE EXTERNAL TABLE silver.rate_code\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/rate_code'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.vw_rate_code\n\nGO\n\nSELECT *\nFROM silver.rate_code\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/11_Create_Silver_Payment_Type_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.payment_type using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.payment_type') IS NOT NULL\n    DROP EXTERNAL TABLE silver.payment_type\nGO\n\nCREATE EXTERNAL TABLE silver.payment_type\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/payment_type'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.vw_payment_type\n\nGO\n\nSELECT *\nFROM silver.payment_type\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/11_Data_Quality_Checks')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "USE nyc_taxi_discovery\nGO\n\n--------------------------------------\n-- Identify Data Quality Issues in trip_amount\n--------------------------------------\n\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n--------------------------------------\n--\n--------------------------------------\nSELECT\n     MIN(total_amount) AS min_total_amount\n    ,MAX(total_amount) AS max_total_amount\n    ,COUNT(1) AS total_number_of_records\n    ,COUNT(total_amount) AS not_null_total_number_of_records\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS [result]   \n\n--------------------------------------\n--\n--------------------------------------\nSELECT  payment_type , COUNT(1) AS number_of_records\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS [result]   \n    --WHERE total_amount < 0\n    GROUP BY payment_type\n    ORDER BY payment_type\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/12_Create_Silver_TripDataGreen_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.vendor using CETAS\n-- As CETAS Statment won't able to create parition folders so replaced it with Stored Procedure\n------------------------------------------------------------\n/*\nIF OBJECT_ID('silver.trip_data_green') IS NOT NULL\n    DROP EXTERNAL TABLE silver.trip_data_green\nGO\n\nCREATE EXTERNAL TABLE silver.trip_data_green\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/trip_data_green'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.trip_data_green_csv\n\nGO\n\nSELECT top 100 *\nFROM  silver.trip_data_green\n*/\n\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='01'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='02'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='03'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='04'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='05'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='06'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='07'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='08'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='09'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='10'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='11'\nEXEC silver.usp_silver_trip_data_green @year='2020' , @month='12'\n\nEXEC silver.usp_silver_trip_data_green @year='2021' , @month='01'\nEXEC silver.usp_silver_trip_data_green @year='2021' , @month='02'\nEXEC silver.usp_silver_trip_data_green @year='2021' , @month='03'\nEXEC silver.usp_silver_trip_data_green @year='2021' , @month='04'\nEXEC silver.usp_silver_trip_data_green @year='2021' , @month='05'\nEXEC silver.usp_silver_trip_data_green @year='2021' , @month='06'\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/12_Join_Data')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "USE nyc_taxi_discovery\nGO\n--------------------------------------------------\n-- Identify no of trips made from each borough\n--------------------------------------------------\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=2020/month=01/*.csv',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n    WHERE PULocationID IS NULL\n\n\n\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n------------------------------------------\n-- Join\n------------------------------------------\nSELECT\n    taxi_zone_data.borough , COUNT(1) AS no_of_records\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS trip_data\n\n    JOIN OPENROWSET(\n                    BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n                    FORMAT = 'CSV',\n            PARSER_VERSION = '2.0',\n                    FIRSTROW = 2 ,\n                    FIELDTERMINATOR = ',',\n                    ROWTERMINATOR = '\\n'\n                )\n                WITH (loation_id SMALLINT 1,\n                borough VARCHAR(15)  2 ,\n                zone VARCHAR(50)  3 ,\n                service_zone VARCHAR(15) 4  \n                )AS taxi_zone_data \n    ON trip_data.PULocationID = taxi_zone_data.loation_id \n    GROUP BY taxi_zone_data.borough\n    ORDER BY  no_of_records ASC;\n\n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/13_Create_Silver_Views')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "\nUSE nyc_taxi_ldw;\nGO\n\nDROP VIEW IF EXISTS silver.vw_trip_data_green\nGO\n\nCREATE VIEW silver.vw_trip_data_green\nAS\n    SELECT\n        \n        --result.filename() as file_name,\n        result.filepath(1) as year, -- 1 here is Position of WildCard  \n        result.filepath(2) as month, -- 2 here is Position of WildCard \n        result.filepath(3) as filename_from_file_path, -- 3 here is Position of WildCard \n        result.*\n    FROM\n        OPENROWSET(\n            BULK '/silver/trip_data_green/year=*/month=*/*.parquet' ,\n            DATA_SOURCE = 'nyc_taxi_src',\n            FORMAT = 'PARQUET'\n        )WITH(\n             vendor_id\tint\n            ,lpep_pickup_datetime\tdatetime2(7)\n            ,lpep_dropoff_datetime\tdatetime2(7)\n            ,store_and_fwd_flag\tCHAR(1)\n            ,rate_code_id\tint\n            ,pu_location_id\tint\n            ,do_location_id\tint\n            ,passenger_count\tint\n            ,trip_distance\tfloat\n            ,fare_amount\tfloat\n            ,extra\tfloat\n            ,mta_tax\tfloat\n            ,tip_amount\tfloat\n            ,tolls_amount\tfloat\n            ,ehail_fee\tint\n            ,improvement_surcharge\tfloat\n            ,total_amount\tfloat\n            ,payment_type\tint\n            ,trip_type\tint\n            ,congestion_surcharge\tfloat\n            ) AS [result] \n        \nGO\n\n\nSELECT  year,month,COUNT(1) AS record_count FROM silver.vw_trip_data_green\nGROUP BY year,month\nORDER BY 1,2\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/13_Simple_Transformation')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "USE nyc_taxi_discovery\nGO\n\n------------------------------------------------------------------\n-- Number of Trips Made by duration in hours\n------------------------------------------------------------------\n\nSELECT top 100\n     DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60 AS from_hour\n    ,(DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60)  + 1 AS to_hour \n    ,COUNT(1) AS number_of_trips\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS trip_data\nGROUP BY DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60 \n    ,(DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60)  + 1\n\nORDER BY from_hour , to_hour\n\n\n\n------------------------------------------------------------------\n-- Number of Trips Made by duration in hours for whole period\n------------------------------------------------------------------\n\nSELECT top 100\n     DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60 AS from_hour\n    ,(DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60)  + 1 AS to_hour \n    ,COUNT(1) AS number_of_trips\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS trip_data\nGROUP BY DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60 \n    ,(DATEDIFF(MINUTE,lpep_pickup_datetime,lpep_dropoff_datetime) / 60)  + 1\n\nORDER BY from_hour , to_hour\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/14_Create_Gold_Trip_Data_Green')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n-- Assignment 1\n\n/*\nSELECT \n        td.year\n       ,td.month\n       ,tz.borough\n       ,CONVERT(DATE,td.lpep_pickup_datetime) AS trip_date\n      ,cal.day_name  AS trip_day\n      ,iif(cal.day_name IN ('Saturday','Sunday'),'Y','N') AS trip_day_weekend_ind\n      ,SUM(iif(pt.description = 'Credit card',1,0)) AS card_trip_count\n      ,SUM(iif(pt.description = 'Cash',1,0)) AS cash_trip_count\nFROM silver.vw_trip_data_green td\nINNER JOIN silver.taxi_zone tz ON (td.pu_location_id = tz.loation_id)\nINNER JOIN silver.calendar cal ON (cal.date = CONVERT(DATE,td.lpep_pickup_datetime))\nINNER JOIN silver.payment_type pt ON (td.payment_type = pt.payment_type)\n\nWHERE td.year = '2020'\n  AND td.month = '01'\n\nGROUP BY td.year\n        ,td.month\n        ,tz.borough\n        ,CONVERT(DATE,td.lpep_pickup_datetime) \n       ,cal.day_name \n\n*/\n\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '01'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '02'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '03'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '04'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '05'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '06'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '07'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '08'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '09'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '10'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '11'\nEXEC gold.usp_gold_trip_data_green @year = '2020' , @month = '12'\n\nEXEC gold.usp_gold_trip_data_green @year = '2021' , @month = '01'\nEXEC gold.usp_gold_trip_data_green @year = '2021' , @month = '02'\nEXEC gold.usp_gold_trip_data_green @year = '2021' , @month = '03'\nEXEC gold.usp_gold_trip_data_green @year = '2021' , @month = '04'\nEXEC gold.usp_gold_trip_data_green @year = '2021' , @month = '05'\nEXEC gold.usp_gold_trip_data_green @year = '2021' , @month = '06'\n\n\n/*\n\nEXEC sp_describe_first_result_set N'SELECT \n        td.year\n       ,td.month\n       ,tz.borough\n       ,CONVERT(DATE,td.lpep_pickup_datetime) AS trip_date\n      ,cal.day_name  AS trip_day\n      ,iif(cal.day_name IN (''Saturday'',''Sunday''),''Y'',''N'') AS trip_day_weekend_ind\n      ,SUM(iif(pt.description = ''Credit card'',1,0)) AS card_trip_count\n      ,SUM(iif(pt.description = ''Cash'',1,0)) AS cash_trip_count\nFROM silver.vw_trip_data_green td\nINNER JOIN silver.taxi_zone tz ON (td.pu_location_id = tz.loation_id)\nINNER JOIN silver.calendar cal ON (cal.date = CONVERT(DATE,td.lpep_pickup_datetime))\nINNER JOIN silver.payment_type pt ON (td.payment_type = pt.payment_type)\n\nWHERE td.year = ''2020''\n  AND td.month = ''01''\n\nGROUP BY td.year\n        ,td.month\n        ,tz.borough\n        ,CONVERT(DATE,td.lpep_pickup_datetime) \n       ,cal.day_name'\n\n*/\n\n\n\n-- Assignment 2\n\n\nSELECT \n        td.year\n       ,td.month\n       ,tz.borough\n       ,CONVERT(DATE,td.lpep_pickup_datetime) AS trip_date\n      ,cal.day_name  AS trip_day\n      ,iif(cal.day_name IN ('Saturday','Sunday'),'Y','N') AS trip_day_weekend_ind\n      ,SUM(iif(pt.description = 'Credit card',1,0)) AS card_trip_count\n      ,SUM(iif(pt.description = 'Cash',1,0)) AS cash_trip_count\n      ,SUM(IIF(tt.trip_type_desc='Street-hail',1,0)) AS Street_hail_trip_count\n      ,SUM(IIF(tt.trip_type_desc='Dispatch',1,0)) AS Dispatch_hail_trip_count\n      ,SUM(td.trip_distance) AS trip_distance\n      ,SUM(DATEDIFF(MINUTE,td.lpep_pickup_datetime,td.lpep_dropoff_datetime)) AS trip_duration\n      ,SUM(td.fare_amount) AS fare_amount\nFROM silver.vw_trip_data_green td\nINNER JOIN silver.taxi_zone tz ON (td.pu_location_id = tz.loation_id)\nINNER JOIN silver.calendar cal ON (cal.date = CONVERT(DATE,td.lpep_pickup_datetime))\nINNER JOIN silver.payment_type pt ON (td.payment_type = pt.payment_type)\nINNER JOIN silver.trip_type tt ON (td.trip_type = tt.trip_type)\n\nWHERE td.year = '2020'\n  AND td.month = '01'\n\nGROUP BY td.year\n        ,td.month\n        ,tz.borough\n        ,CONVERT(DATE,td.lpep_pickup_datetime) \n       ,cal.day_name \n\n\n\nselect * from  silver.trip_type\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/14_Discovery_Assignment')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "USE nyc_taxi_discovery\nGO\n\n------------------------------------------------------------------\n-- Explre the data first\n------------------------------------------------------------------\n\nSELECT top 10\n    *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS trip_data\n\n    JOIN OPENROWSET(\n                    BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n                    FORMAT = 'CSV',\n            PARSER_VERSION = '2.0',\n                    FIRSTROW = 2 ,\n                    FIELDTERMINATOR = ',',\n                    ROWTERMINATOR = '\\n'\n                )\n                WITH (loation_id SMALLINT 1,\n                borough VARCHAR(15)  2 ,\n                zone VARCHAR(50)  3 ,\n                service_zone VARCHAR(15) 4  \n                )AS taxi_zone_data \n    ON trip_data.PULocationID = taxi_zone_data.loation_id \n\n    JOIN (\n                SELECT payment_type ,  payment_type_desc\n                    FROM OPENROWSET(\n                    BULK 'payment_type.json' ,\n                    DATA_SOURCE = 'nyc_taxi_data_raw' ,\n                    FORMAT = 'CSV',\n                    FIELDTERMINATOR = '0x0b', -- Vertical Tab\n                    FIELDQUOTE = '0x0b' -- Vertical Tab\n                    )WITH(  \n                        jsonDoc NVARCHAR(MAX)\n                    ) AS payment_type\n                    CROSS APPLY OPENJSON(jsonDoc) \n                    WITH (\n                            payment_type SMALLINT ,\n                            payment_type_desc VARCHAR(15)\n                    )\n\n        ) AS payment_type_data ON trip_data.payment_type = payment_type_data.payment_type\n        WHERE trip_data.payment_type IN ( 1,2)\n    --GROUP BY taxi_zone_data.borough\n    --ORDER BY  no_of_records ASC;\n\n------------------------------------------------------------------\n-- Normal Query\n------------------------------------------------------------------\n\nSELECT top 10\n    taxi_zone_data.borough\n    ,COUNT(1) AS total_trips\n    ,SUM(CASE WHEN trip_data.payment_type = 1 THEN 1 ELSE NULL END) AS cash_trips\n    ,SUM(CASE WHEN trip_data.payment_type = 2 THEN 1 ELSE NULL END) AS card_trips\n    ,(SUM(CASE WHEN trip_data.payment_type = 1 THEN 1 ELSE NULL END) / (COUNT(1)*1.0 )) * 100  AS cash_trips_percentage\n    ,(SUM(CASE WHEN trip_data.payment_type = 2 THEN 1 ELSE NULL END) / (COUNT(1)*1.0 )) * 100  AS card_trips_percentage\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2021/month=01/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS trip_data\n\n    JOIN OPENROWSET(\n                    BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n                    FORMAT = 'CSV',\n            PARSER_VERSION = '2.0',\n                    FIRSTROW = 2 ,\n                    FIELDTERMINATOR = ',',\n                    ROWTERMINATOR = '\\n'\n                )\n                WITH (loation_id SMALLINT 1,\n                borough VARCHAR(15)  2 ,\n                zone VARCHAR(50)  3 ,\n                service_zone VARCHAR(15) 4  \n                )AS taxi_zone_data \n    ON trip_data.PULocationID = taxi_zone_data.loation_id \n\n    JOIN (\n                SELECT payment_type ,  payment_type_desc\n                    FROM OPENROWSET(\n                    BULK 'payment_type.json' ,\n                    DATA_SOURCE = 'nyc_taxi_data_raw' ,\n                    FORMAT = 'CSV',\n                    FIELDTERMINATOR = '0x0b', -- Vertical Tab\n                    FIELDQUOTE = '0x0b' -- Vertical Tab\n                    )WITH(  \n                        jsonDoc NVARCHAR(MAX)\n                    ) AS payment_type\n                    CROSS APPLY OPENJSON(jsonDoc) \n                    WITH (\n                            payment_type SMALLINT ,\n                            payment_type_desc VARCHAR(15)\n                    )\n\n        ) AS payment_type_data ON trip_data.payment_type = payment_type_data.payment_type\n        WHERE trip_data.payment_type IN ( 1,2)\n    GROUP BY taxi_zone_data.borough\n    --ORDER BY  no_of_records ASC;\n\n\n\n------------------------------------------------------------------\n-- using CTE\n------------------------------------------------------------------    \n\n;with trip_data AS\n(\n    SELECT * FROM\n        OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2021/month=01/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS trip_data\n),taxi_zone_data  AS\n(\n    SELECT * FROM\n    OPENROWSET(\n                    BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n                    FORMAT = 'CSV',\n            PARSER_VERSION = '2.0',\n                    FIRSTROW = 2 ,\n                    FIELDTERMINATOR = ',',\n                    ROWTERMINATOR = '\\n'\n                )\n                WITH (loation_id SMALLINT 1,\n                borough VARCHAR(15)  2 ,\n                zone VARCHAR(50)  3 ,\n                service_zone VARCHAR(15) 4  \n                )AS taxi_zone_data \n),payment_type_data AS\n(\n    SELECT payment_type ,  payment_type_desc\n                    FROM OPENROWSET(\n                    BULK 'payment_type.json' ,\n                    DATA_SOURCE = 'nyc_taxi_data_raw' ,\n                    FORMAT = 'CSV',\n                    FIELDTERMINATOR = '0x0b', -- Vertical Tab\n                    FIELDQUOTE = '0x0b' -- Vertical Tab\n                    )WITH(  \n                        jsonDoc NVARCHAR(MAX)\n                    ) AS payment_type\n                    CROSS APPLY OPENJSON(jsonDoc) \n                    WITH (\n                            payment_type SMALLINT ,\n                            payment_type_desc VARCHAR(15)\n                    )\n\n)\nSELECT top 10\n    taxi_zone_data.borough\n    ,COUNT(1) AS total_trips\n    ,SUM(CASE WHEN payment_type_data.payment_type_desc = 'Credit card'  THEN 1 ELSE 0 END) AS card_trips\n    ,SUM(CASE WHEN payment_type_data.payment_type_desc = 'Cash'         THEN 1 ELSE 0 END) AS cash_trips\n    ,(SUM(CASE WHEN payment_type_data.payment_type_desc = 'Credit card' THEN 1 ELSE 0 END) / (COUNT(1)*1.0 )) * 100  AS card_trips_percentage\n    ,(SUM(CASE WHEN payment_type_data.payment_type_desc = 'Cash'        THEN 1 ELSE 0 END) / (COUNT(1)*1.0 )) * 100  AS cash_trips_percentage\nFROM\n    trip_data \n    LEFT JOIN taxi_zone_data ON trip_data.PULocationID = taxi_zone_data.loation_id \n    LEFT JOIN payment_type_data ON trip_data.payment_type = payment_type_data.payment_type\nWHERE payment_type_data.payment_type_desc  IN ( 'Credit card','Cash')\nGROUP BY taxi_zone_data.borough\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/15_Create_Gold_Views')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "\nUSE nyc_taxi_ldw;\nGO\n\nDROP VIEW IF EXISTS gold.vw_trip_data_green\nGO\n\nCREATE VIEW gold.vw_trip_data_green\nAS\n    SELECT\n        \n        --result.filename() as file_name,\n        result.filepath(1) as year, -- 1 here is Position of WildCard  \n        result.filepath(2) as month, -- 2 here is Position of WildCard \n        result.filepath(3) as filename_from_file_path, -- 3 here is Position of WildCard \n        result.*\n    FROM\n        OPENROWSET(\n            BULK '/gold/trip_data_green/year=*/month=*/*.parquet' ,\n            DATA_SOURCE = 'nyc_taxi_src',\n            FORMAT = 'PARQUET'\n        )WITH(\n             borough VARCHAR(15),\n             trip_date DATE,\n             trip_day VARCHAR(15),\n             trip_day_weekend_ind CHAR(1),\n             card_trip_count INT,\n             cash_trip_count INT,\n             Street_hail_trip_count INT,\n             Dispatch_hail_trip_count INT,\n             trip_distance FLOAT,\n             trip_duration INT,\n             fare_amount FLOAT\n\n            ) AS [result] \n        \nGO\n\n\nSELECT top 100 * FROM gold.vw_trip_data_green\n\nSELECT year,month,count(1) FROM gold.vw_trip_data_green\nGROUP BY year,month\nORDER BY 1,2\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_12_usp_silver_trip_data_green')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nCREATE OR ALTER PROCEDURE silver.usp_silver_trip_data_green\n@year VARCHAR(4),\n@month VARCHAR(2)\nAS\nBEGIN\n\n    DECLARE @create_sql_stmt NVARCHAR(MAX);\n    DECLARE @drop_sql_stmt NVARCHAR(MAX);\n    \n    SET @create_sql_stmt =\n        N'CREATE EXTERNAL TABLE silver.trip_data_green_'+@year+'_'+@month+'\n            WITH(\n                    DATA_SOURCE = nyc_taxi_src\n                    ,LOCATION = ''silver/trip_data_green/year='+@year + '/month='+@month+'''\n                    ,FILE_FORMAT = parquet_file_format,\n            )\n            AS\n            SELECT   [VendorID]\t AS vendor_id\n                    ,[lpep_pickup_datetime]\t\n                    ,[lpep_dropoff_datetime]\t\n                    ,[store_and_fwd_flag]\t\n                    ,[RatecodeID ] AS rate_code_id\t\n                    ,[PULocationID]  AS pu_location_id\t\t\n                    ,[DOLocationID]  AS do_location_id\t\t\n                    ,[passenger_count]\t\n                    ,[trip_distance]\n                    ,[fare_amount]\t\n                    ,[extra]\t\n                    ,[mta_tax]\t\n                    ,[tip_amount]\t\n                    ,[tolls_amount]\t\n                    ,[ehail_fee]\t\n                    ,[improvement_surcharge]\t\n                    ,[total_amount]\t\n                    ,[payment_type]\t\n                    ,[trip_type]\t\n                    ,[congestion_surcharge]\t\n            FROM bronze.vw_trip_data_green_csv\n            WHERE year ='''+@year +'''\n            AND month='''+@month+'''';\n\n    PRINT  @create_sql_stmt \n\n    EXEC (@create_sql_stmt)\n\n    SET @drop_sql_stmt = \n        N'DROP EXTERNAL TABLE silver.trip_data_green_'+@year+'_'+@month ;\n\n    EXEC (@drop_sql_stmt )\n    PRINT  @drop_sql_stmt \n\nEND\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_Create_Databases')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "use master\nGO\n\nCREATE DATABASE nyc_taxi_ldw\nGO\n\nALTER DATABASE nyc_taxi_ldw COLLATE Latin1_General_100_BIN2_UTF8\n\nGO\n\nUSE nyc_taxi_ldw\nGO\n\nCREATE SCHEMA bronze\nGO\nCREATE SCHEMA silver\nGO\nCREATE SCHEMA gold",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_Explore_CSV_Taxi_Zone')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "\n-- Read Taxi_Zone.csv\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\n-- This is auto-generated code\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'https://azuresynapsecoursedl.dfs.core.windows.net/nyc-taxi-data/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0'\n    ) AS [result]\n\n-- abfss protocol\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    ) AS [result]\n\n\n\n-- Examine the Data Types\nEXEC sp_describe_first_result_set N'SELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK ''abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv'',\n        FORMAT = ''CSV'',\nPARSER_VERSION = ''2.0'',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = '','',\n        ROWTERMINATOR = ''\\n''\n    ) AS [result]'\n\n-- Find the Max Length of each column\nSELECT\n    MAX(LEN(LocationID))  as len_LocationID,\n    MAX(LEN(Borough))  as len_Borough,\n    MAX(LEN(Zone))  as len_Zone,\n    MAX(LEN(service_zone))  as len_service_zone\n\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    ) AS [result]\n\n\n-- Use WITH Clause to Specify DataTypes . Field Names are Case Sensitive by default\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (LocationID SMALLINT ,\n    Borough VARCHAR(15) ,\n    Zone VARCHAR(50) ,\n    service_zone VARCHAR(15) \n    )AS [result]\n\n\n-- Now Check the Data Types Again\n\nEXEC sp_describe_first_result_set N'SELECT\n    *\nFROM\n    OPENROWSET(\n        BULK ''abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv'',\n        FORMAT = ''CSV'',\nPARSER_VERSION = ''2.0'',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = '','',\n        ROWTERMINATOR = ''\\n''\n    )\n    WITH (LocationID SMALLINT ,\n    Borough VARCHAR(15) ,\n    Zone VARCHAR(50) ,\n    service_zone VARCHAR(15) \n    )AS [result]'\n\n--\n\nselect name,collation_name from sys.databases\n\n\n\n-- Specify the Collation\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (LocationID SMALLINT,\n    Borough VARCHAR(15)   COLLATE Latin1_General_100_CI_AI_SC_UTF8,\n    Zone VARCHAR(50)   COLLATE Latin1_General_100_CI_AI_SC_UTF8,\n    service_zone VARCHAR(15)   COLLATE Latin1_General_100_CI_AI_SC_UTF8\n    )AS [result]\n\n\n-- Change Database COLLATION\n\nCREATE DATABASE nyc_taxi_discovery\n\nUSE nyc_taxi_discovery\n\nALTER DATABASE nyc_taxi_discovery COLLATE Latin1_General_100_CI_AI_SC_UTF8\n\n-- No Wanring of Collation as the Collation is set in nyc-taxi-discovery and we are running below query under this database \n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (LocationID SMALLINT,\n    Borough VARCHAR(15)   ,\n    Zone VARCHAR(50)   ,\n    service_zone VARCHAR(15)  \n    )AS [result]\n\n-- Select only subset of columns\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (\n    Borough VARCHAR(15)   ,\n    Zone VARCHAR(50)   \n    )AS [result]\n\n-- Read a file without a header\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone_without_header.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (LocationID SMALLINT,\n    Borough VARCHAR(15)   ,\n    Zone VARCHAR(50)   ,\n    service_zone VARCHAR(15)  \n    )AS [result]\n\n-- Specify Ordinal Position\n SELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone_without_header.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (\n    Borough VARCHAR(15)   2,\n    Zone VARCHAR(50)  3 \n    )AS [result]   \n\n-- You can place the Column Name in any order as it will read thru Ordinal Position\n SELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone_without_header.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (\n    Zone VARCHAR(50)  3 ,\n    Borough VARCHAR(15)   2\n    \n    )AS [result]   \n\n-- Fix Column Names .  Ignore Header Specify the First Row in the File\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIRSTROW = 2 ,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (loation_id SMALLINT 1,\n    borough VARCHAR(15)  2 ,\n    zone VARCHAR(50)  3 ,\n    service_zone VARCHAR(15) 4  \n    )AS [result]\n\n\n-- Create External Data Source . EDS can only be created in User Defind Databases.\n\nCREATE EXTERNAL DATA SOURCE nyc_taxi_data\nWITH ( \n    LOCATION = 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/'    \n)\n\nCREATE EXTERNAL DATA SOURCE nyc_taxi_data_raw\nWITH ( \n    LOCATION = 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw'    \n)\n\n  -- List All the External Data Sources\n\n  SELECT * FROM sys.external_data_sources \n\n--DROP EXTERNAL DATA SOURCE nyc_taxi_data\n\n-- Use the EDS to load the CSV\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'raw/taxi_zone.csv',\n        DATA_SOURCE = 'nyc_taxi_data',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIRSTROW = 2 ,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (loation_id SMALLINT 1,\n    borough VARCHAR(15)  2 ,\n    zone VARCHAR(50)  3 ,\n    service_zone VARCHAR(15) 4  \n    )AS [result]\n\n-- use raw EDS \n \nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'taxi_zone.csv',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        FIRSTROW = 2 ,\n        FIELDTERMINATOR = ',',\n        ROWTERMINATOR = '\\n'\n    )\n    WITH (loation_id SMALLINT 1,\n    borough VARCHAR(15)  2 ,\n    zone VARCHAR(50)  3 ,\n    service_zone VARCHAR(15) 4  \n    )AS [result]   \n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_ctas_trip_data_green_aggregate')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/3_dwh_dedicated_sql_pool"
				},
				"content": {
					"query": "\nCREATE SCHEMA staging\nGO\n\n---- CReate a Dedicated SQL Pool and run the below commands\n\nIF NOT EXISTS (SELECT * FROM sys.external_file_formats WHERE name = 'parquet_file_format') \n\tCREATE EXTERNAL FILE FORMAT [parquet_file_format] \n\tWITH ( FORMAT_TYPE = PARQUET)\nGO\n\nIF NOT EXISTS (SELECT * FROM sys.external_data_sources WHERE name = 'nyc_taxi_data_src') \n\tCREATE EXTERNAL DATA SOURCE nyc_taxi_data_src\n\tWITH (\n\t\tLOCATION = 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net' \n\t)\nGO\n\nCREATE EXTERNAL TABLE staging.ext_trip_data_green_agg (\n\t[pu_location_id] int,\n\t[do_location_id] int,\n\t[total_trip_count] bigint,\n\t[total_fare_amount] float\n\t)\n\tWITH (\n\tLOCATION = 'gold/trip_data_green_agg',\n\tDATA_SOURCE = nyc_taxi_data_src,\n\tFILE_FORMAT = parquet_file_format\n\t)\nGO\n\n\nSELECT TOP 100 * FROM staging.ext_trip_data_green_agg\nGO\n\n\nCREATE SCHEMA dwh\n\nGO\n\nCREATE TABLE dwh.trip_data_green_agg\nWITH(\n\t\tCLUSTERED COLUMNSTORE INDEX ,\n\t\tDISTRIBUTION =ROUND_ROBIN\n\n)\nAS SELECT * FROM staging.ext_trip_data_green_agg\n\n\nGO\n\nSELECT * FROM dwh.trip_data_green_agg\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_data_dedicated",
						"poolName": "nyc_taxi_data_dedicated"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_synapse_link_query_heartbit_cosmosdb')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/synapselink-cosmosdb"
				},
				"content": {
					"query": "IF (NOT EXISTS(SELECT * FROM sys.credentials WHERE name = 'azure-synapse-course-cosmos-db'))\n    \n    CREATE CREDENTIAL [azure-synapse-course-cosmos-db]\n    WITH IDENTITY = 'SHARED ACCESS SIGNATURE', SECRET = 'W2xnebxGYicO6JwMHO7Do7Qj7mPDqA8cJsdgU1oMbLe1xiZ4xesn1ifwpA5yR60TmeNLG3bzwyEQACDbVgkmKQ=='\nGO\n\n-- Serverless SQL ONLY Pulls the data from Synapse Analytical Store\n\nSELECT TOP 100 *\nFROM OPENROWSET(PROVIDER = 'CosmosDB',\n                CONNECTION = 'Account=azure-synapse-course-cosmos-db;Database=nyctaxidb',\n                OBJECT = 'Heartbeat',\n                SERVER_CREDENTIAL = 'azure-synapse-course-cosmos-db'\n) AS [Heartbeat]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2_14_usp_gold_trip_data_green')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nCREATE OR ALTER PROCEDURE gold.usp_gold_trip_data_green\n@year VARCHAR(4) ,\n@month VARCHAR(2)\nAS\nBEGIN\n\n    DECLARE @create_sql_stmt NVARCHAR(MAX);\n    DECLARE @drop_sql_stmt NVARCHAR(MAX);\n    \n    /*\n    SET @create_sql_stmt =\n        N'CREATE EXTERNAL TABLE gold.trip_data_green_'+@year+'_'+@month+'\n            WITH(\n                    DATA_SOURCE = nyc_taxi_src\n                    ,LOCATION = ''gold/trip_data_green/year='+@year + '/month='+@month+'''\n                    ,FILE_FORMAT = parquet_file_format,\n            )\n            AS\n            SELECT \n                td.year\n                ,td.month\n                ,tz.borough\n                ,CONVERT(DATE,td.lpep_pickup_datetime) AS trip_date\n                ,cal.day_name AS trip_day\n                ,iif(cal.day_name IN (''Saturday'',''Sunday''),''Y'',''N'') AS trip_day_weekend_ind\n                ,SUM(iif(pt.description = ''Credit card'',1,0)) AS card_trip_count\n                ,SUM(iif(pt.description = ''Cash'',1,0)) AS cash_trip_count\n            FROM silver.vw_trip_data_green td\n            INNER JOIN silver.taxi_zone tz ON (td.pu_location_id = tz.loation_id)\n            INNER JOIN silver.calendar cal ON (cal.date = CONVERT(DATE,td.lpep_pickup_datetime))\n            INNER JOIN silver.payment_type pt ON (td.payment_type = pt.payment_type)\n            WHERE td.year ='''+@year +'''\n            AND td.month='''+@month+'''\n            \n            GROUP BY td.year\n                    ,td.month\n                    ,tz.borough\n                    ,CONVERT(DATE,td.lpep_pickup_datetime) \n                    ,cal.day_name';\n        */\n\n\nSET @create_sql_stmt =\n        N'CREATE EXTERNAL TABLE gold.trip_data_green_'+@year+'_'+@month+'\n            WITH(\n                    DATA_SOURCE = nyc_taxi_src\n                    ,LOCATION = ''gold/trip_data_green/year='+@year + '/month='+@month+'''\n                    ,FILE_FORMAT = parquet_file_format,\n            )\n            AS\n            SELECT \n                td.year\n                ,td.month\n                ,tz.borough\n                ,CONVERT(DATE,td.lpep_pickup_datetime) AS trip_date\n                ,cal.day_name AS trip_day\n                ,iif(cal.day_name IN (''Saturday'',''Sunday''),''Y'',''N'') AS trip_day_weekend_ind\n                ,SUM(iif(pt.description = ''Credit card'',1,0)) AS card_trip_count\n                ,SUM(iif(pt.description = ''Cash'',1,0)) AS cash_trip_count                \n                ,SUM(IIF(tt.trip_type_desc=''Street-hail'',1,0)) AS Street_hail_trip_count\n                ,SUM(IIF(tt.trip_type_desc=''Dispatch'',1,0)) AS Dispatch_hail_trip_count\n                ,SUM(td.trip_distance) AS trip_distance\n                ,SUM(DATEDIFF(MINUTE,td.lpep_pickup_datetime,td.lpep_dropoff_datetime)) AS trip_duration\n                ,SUM(td.fare_amount) AS fare_amount\n            FROM silver.vw_trip_data_green td\n            INNER JOIN silver.taxi_zone tz ON (td.pu_location_id = tz.loation_id)\n            INNER JOIN silver.calendar cal ON (cal.date = CONVERT(DATE,td.lpep_pickup_datetime))\n            INNER JOIN silver.payment_type pt ON (td.payment_type = pt.payment_type)     \n            INNER JOIN silver.trip_type tt ON (td.trip_type = tt.trip_type)       \n            WHERE td.year ='''+@year +'''\n            AND td.month='''+@month+'''            \n            GROUP BY td.year\n                    ,td.month\n                    ,tz.borough\n                    ,CONVERT(DATE,td.lpep_pickup_datetime) \n                    ,cal.day_name';\n\n\n    PRINT  @create_sql_stmt \n\n    EXEC (@create_sql_stmt)\n\n    SET @drop_sql_stmt = \n        N'DROP EXTERNAL TABLE gold.trip_data_green_'+@year+'_'+@month ;\n\n    EXEC (@drop_sql_stmt )\n    PRINT  @drop_sql_stmt \n\nEND\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2_Create_External_Data_Sources')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nIF EXISTS (SELECT 1 FROM sys.external_data_sources WHERE name = 'nyc_taxi_src')\nDROP EXTERNAL DATA SOURCE nyc_taxi_src\nGO\nCREATE EXTERNAL DATA SOURCE nyc_taxi_src\nWITH\n(   LOCATION = 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/'\n);\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2_Explore_CSV_Calendar')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "\n-- Read Calendar.csv\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nuse nyc_taxi_discovery\nGO\n\nSELECT * FROM OPENROWSET\n(\n BULK 'calendar.csv',\n DATA_SOURCE = 'nyc_taxi_data_raw',\n FORMAT = 'CSV',\n PARSER_VERSION = '2.0',\n FIRSTROW = 2,\n FIELDTERMINATOR = ','\n) AS result\n\n\n-- Check the DataTypes\nEXEC sp_describe_first_result_set N'SELECT * FROM OPENROWSET\n(\n BULK ''calendar.csv'',\n DATA_SOURCE = ''nyc_taxi_data_raw'',\n FORMAT = ''CSV'',\n PARSER_VERSION = ''2.0'',\n FIRSTROW = 2,\n FIELDTERMINATOR = '',''\n) AS result'\n\n\n-- Specify the Columns\n\nSELECT * FROM OPENROWSET\n(\n BULK 'calendar.csv',\n DATA_SOURCE = 'nyc_taxi_data_raw',\n FORMAT = 'CSV',\n PARSER_VERSION = '2.0',\n FIRSTROW = 2,\n FIELDTERMINATOR = ','\n)WITH(\n date_key   INT 1\n,date       DATE 2\n,year       INT 3\n,month      SMALLINT 4\n,day        SMALLINT 5\n,day_name   VARCHAR(15) 6\n,day_of_year    SMALLINT 7\n,week_of_month  SMALLINT 8\n,week_of_year   SMALLINT 9\n,month_name     VARCHAR(15) 10\n,year_month     INT 11\n,year_week      INT 12\n\n) AS result\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2_trip_data_green_agg_copy')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/3_dwh_dedicated_sql_pool"
				},
				"content": {
					"query": "-- Create a Dedicated SQL Pool and run the below commands\n\n-- Documentation :\n--https://learn.microsoft.com/en-us/sql/t-sql/statements/copy-into-transact-sql?view=azure-sqldw-latest\n\n-- IF NOT EXISTS (SELECT * FROM sys.objects O JOIN sys.schemas S ON O.schema_id = S.schema_id WHERE O.NAME = 'trip_data_green_agg_copy' AND O.TYPE = 'U' AND S.NAME = 'dwh')\n-- CREATE TABLE dwh.trip_data_green_agg_copy\n-- \t(\n-- \t [pu_location_id] int,\n-- \t [do_location_id] int,\n-- \t [total_trip_count] bigint,\n-- \t [total_fare_amount] float\n-- \t)\n-- WITH\n-- \t(\n-- \tDISTRIBUTION = ROUND_ROBIN,\n-- \t CLUSTERED COLUMNSTORE INDEX\n-- \t -- HEAP\n-- \t)\n-- GO\n\n--Uncomment the 4 lines below to create a stored procedure for data pipeline orchestration\n--CREATE PROC bulk_load_trip_data_green_agg_copy\n--AS\n--BEGIN\nCOPY INTO dwh.trip_data_green_agg_copy\n--(pu_location_id 1, do_location_id 2, total_trip_count 3, total_fare_amount 4)\nFROM 'https://azuresynapsecoursedl.dfs.core.windows.net/nyc-taxi-data/gold/trip_data_green_agg'\nWITH\n(\n\tFILE_TYPE = 'PARQUET'\n\t,MAXERRORS = 0\n\t,COMPRESSION = 'snappy'\n\t,AUTO_CREATE_TABLE  = 'ON'\n)\n--END\nGO\n\nSELECT TOP 100 * FROM dwh.trip_data_green_agg_copy\nGO\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_data_dedicated",
						"poolName": "nyc_taxi_data_dedicated"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/3_6_usp_Create_Silver_Taxi_Zone_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.taxi_zone using CETAS\n------------------------------------------------------------\n\nCREATE OR ALTER PROCEDURE silver.usp_silver_taxi_zone\nAS\nBEGIN\n\nIF EXISTS (SELECT 1 FROM sys.external_tables WHERE name = 'taxi_zone')\n    DROP EXTERNAL TABLE silver.taxi_zone\n\nCREATE EXTERNAL TABLE silver.taxi_zone\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/taxi_zone'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.taxi_zone;\n\n\nEND\nGO\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/3_Create_External_File_Formats')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n----------------------------------------\n-- External File Formats for \"csv\" files\n----------------------------------------\n-- Create an external file format for DELIMITED (CSV/TSV) files.\nIF EXISTS (SELECT 1 FROM sys.external_file_formats WHERE name = 'csv_file_format')\n    DROP EXTERNAL FILE FORMAT csv_file_format\n\nCREATE EXTERNAL FILE FORMAT csv_file_format\nWITH (\n        FORMAT_TYPE = DELIMITEDTEXT\n      , FORMAT_OPTIONS (\n\n        FIELD_TERMINATOR = ','\n       ,STRING_DELIMITER = '\"'\n       ,FIRST_ROW = 2 \n       ,USE_TYPE_DEFAULT = FALSE\n       ,ENCODING = 'UTF8'\n       ,PARSER_VERSION = '2.0'\n        )\n    \n    );\n\n\n--------------------------------------------------------------------------------\n-- External File Formats for \"csv files with PARSER VERSION = 1.0\"\n--------------------------------------------------------------------------------\n\nIF EXISTS (SELECT 1 FROM sys.external_file_formats WHERE name = 'csv_file_format_pv1')\n    DROP EXTERNAL FILE FORMAT csv_file_format_pv1\n-- Create an external file format for DELIMITED (CSV/TSV) files.\nCREATE EXTERNAL FILE FORMAT csv_file_format_pv1\nWITH (\n        FORMAT_TYPE = DELIMITEDTEXT\n      , FORMAT_OPTIONS (\n        FIELD_TERMINATOR = ','\n       ,STRING_DELIMITER = '\"'\n       ,FIRST_ROW = 2 \n       ,USE_TYPE_DEFAULT = FALSE\n       ,ENCODING = 'UTF8'\n       ,PARSER_VERSION = '1.0'\n        )\n    \n    );\n\n----------------------------------------\n-- External File Formats for \"tsv\" files\n----------------------------------------\n\nIF EXISTS (SELECT 1 FROM sys.external_file_formats WHERE name = 'tsv_file_format')\n    DROP EXTERNAL FILE FORMAT tsv_file_format\n-- Create an external file format for DELIMITED (CSV/TSV) files.\nCREATE EXTERNAL FILE FORMAT tsv_file_format\nWITH (\n        FORMAT_TYPE = DELIMITEDTEXT\n      , FORMAT_OPTIONS (\n\n        FIELD_TERMINATOR = '\\t'\n       ,STRING_DELIMITER = '\"'\n       ,FIRST_ROW = 2 \n       ,USE_TYPE_DEFAULT = FALSE\n       ,ENCODING = 'UTF8'\n       ,PARSER_VERSION = '2.0'\n        )\n    \n    );\n\n--------------------------------------------------\n-- External File Formats for \"PARQUET\" files\n--------------------------------------------------\n--Create an external file format for PARQUET files.\n\nIF EXISTS (SELECT 1 FROM sys.external_file_formats WHERE name = 'parquet_file_format')\n    DROP EXTERNAL FILE FORMAT parquet_file_format\n\nCREATE EXTERNAL FILE FORMAT parquet_file_format\nWITH (\n        FORMAT_TYPE = PARQUET\n      , DATA_COMPRESSION = 'org.apache.hadoop.io.compress.SnappyCodec'\n    );\n\n--------------------------------------------------\n-- External File Formats for \"DELTA\" files\n--------------------------------------------------\n\n\nIF EXISTS (SELECT 1 FROM sys.external_file_formats WHERE name = 'delta_file_format')\n    DROP EXTERNAL FILE FORMAT delta_file_format\n\nCREATE EXTERNAL FILE FORMAT delta_file_format\nWITH (\n        FORMAT_TYPE = DELTA\n    );\n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/3_Explore_CSV_Vendor')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "-- Read Vendor.csv\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nUSE nyc_taxi_discovery\nGO\n\n-- Unquoted File\n\nSELECT * FROM OPENROWSET\n(\n BULK 'vendor_unquoted.csv',\n DATA_SOURCE = 'nyc_taxi_data_raw',\n FORMAT = 'CSV',\n PARSER_VERSION = '2.0',\n HEADER_ROW = TRUE,\n FIELDTERMINATOR = ','\n) AS result\n\n\n-- Escaped File\nSELECT * FROM OPENROWSET\n(\n BULK 'vendor_escaped.csv',\n DATA_SOURCE = 'nyc_taxi_data_raw',\n FORMAT = 'CSV',\n PARSER_VERSION = '2.0',\n HEADER_ROW = TRUE,\n FIELDTERMINATOR = ',',\n ESCAPECHAR = '\\\\'\n) AS result\n\n\n-- Quoted File with \"\nSELECT * FROM OPENROWSET\n(\n BULK 'vendor.csv',\n DATA_SOURCE = 'nyc_taxi_data_raw',\n FORMAT = 'CSV',\n PARSER_VERSION = '2.0',\n HEADER_ROW = TRUE,\n FIELDTERMINATOR = ',',\n FIELDQUOTE = '\"'\n)WITH(\n        vendor_id TINYINT 1,\n        vendor_name VARCHAR(100) 2\n\n) AS result\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/4_7_usp_Create_Silver_Calendar_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nCREATE OR ALTER PROCEDURE silver.usp_silver_calendar\nAS\nBEGIN\n------------------------------------------------------------\n-- External Table Name :  silver.calendar using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.calendar') IS NOT NULL\n    DROP EXTERNAL TABLE silver.calendar\n\n\nCREATE EXTERNAL TABLE silver.calendar\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/calendar'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.calendar ;\n\nEND\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/4_Create_External_Tables')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n----------------------------------------\n-- External Table Name :  bronze.taxi_zone\n----------------------------------------\n\nIF EXISTS (SELECT 1 FROM sys.external_tables WHERE name = 'taxi_zone')\n    DROP EXTERNAL TABLE bronze.taxi_zone\n\n-- or\n--IF OBJECT_ID('bronze.taxi_zone') IS NOT NULL\n--DROP EXTERNAL TABLE bronze.taxi_zone\n\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.taxi_zone\n    ( loation_id SMALLINT ,\n    borough VARCHAR(15)   ,\n    zone VARCHAR(50)   ,\n    service_zone VARCHAR(15)   )\n    WITH (\n        LOCATION = 'raw/taxi_zone.csv',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = csv_file_format,\n        --FILE_FORMAT = csv_file_format_pv1, -- To Show the error Lines\n        REJECT_VALUE = 10 ,\n        REJECTED_ROW_LOCATION = 'rejections/taxi_zone'\n         \n    );\n\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.taxi_zone\n\n----------------------------------------\n-- To Demonstrate Error Handling Mechanism\n----------------------------------------\n\nIF OBJECT_ID('bronze.taxi_zone_error') IS NOT NULL\n    DROP EXTERNAL TABLE bronze.taxi_zone_error\n\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.taxi_zone_error\n    ( loation_id SMALLINT ,\n    borough VARCHAR(8)   , -- Changed from 15 to 1\n    zone VARCHAR(50)   ,\n    service_zone VARCHAR(15)   )\n    WITH (\n        LOCATION = 'raw/taxi_zone.csv',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = csv_file_format_pv1, -- To Show the error Lines .\n        REJECT_VALUE = 10 ,\n        REJECTED_ROW_LOCATION = 'rejections/taxi_zone'\n         \n    );\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.taxi_zone_error\n\n\n\n----------------------------------------\n-- External Table Name : bronze.calendar\n----------------------------------------\n\nIF OBJECT_ID('bronze.calendar') IS NOT NULL\n    DROP EXTERNAL TABLE bronze.calendar\n\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.calendar\n    (    date_key   INT \n        ,date       DATE \n        ,year       INT \n        ,month      SMALLINT \n        ,day        SMALLINT \n        ,day_name   VARCHAR(15) \n        ,day_of_year    SMALLINT \n        ,week_of_month  SMALLINT \n        ,week_of_year   SMALLINT \n        ,month_name     VARCHAR(15) \n        ,year_month     INT \n        ,year_week      INT \n )\n    WITH (\n        LOCATION = 'raw/calendar.csv',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = csv_file_format, \n        REJECT_VALUE = 10 ,\n        REJECTED_ROW_LOCATION = 'rejections/calendar'\n         \n    );\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.calendar\n\n\n----------------------------------------\n-- External Table Name : bronze.vendor\n----------------------------------------\n\nIF OBJECT_ID('bronze.vendor') IS NOT NULL\n    DROP EXTERNAL TABLE bronze.vendor\n\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.vendor\n    (    vendor_id TINYINT ,\n        vendor_name VARCHAR(100) \n )\n    WITH (\n        LOCATION = 'raw/vendor.csv',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = csv_file_format, \n        REJECT_VALUE = 10 ,\n        REJECTED_ROW_LOCATION = 'rejections/vendor'\n         \n    );\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.vendor\n\n\n----------------------------------------\n-- External Table Name : bronze.trip_type\n----------------------------------------\n\nIF OBJECT_ID('bronze.trip_type') IS NOT NULL\n    DROP EXTERNAL TABLE bronze.trip_type\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.trip_type\n    (    trip_type SMALLINT ,\n         trip_type_desc VARCHAR(30) \n )\n    WITH (\n        LOCATION = 'raw/trip_type.tsv',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = tsv_file_format, \n        REJECT_VALUE = 10 ,\n        REJECTED_ROW_LOCATION = 'rejections/trip_type'\n         \n    );\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.trip_type;\n\n----------------------------------------\n-- External Table Name : bronze.trip_data_green_parquet\n----------------------------------------\n\nIF OBJECT_ID('bronze.trip_data_green_csv') IS NOT NULL\n        DROP EXTERNAL TABLE bronze.trip_data_green_csv\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.trip_data_green_csv\n    (    \n      VendorID\tint\n    ,lpep_pickup_datetime\tdatetime2(7)\n    ,lpep_dropoff_datetime\tdatetime2(7)\n    ,store_and_fwd_flag\tCHAR(1)\n    ,RatecodeID\tint\n    ,PULocationID\tint\n    ,DOLocationID\tint\n    ,passenger_count\tint\n    ,trip_distance\tfloat\n    ,fare_amount\tfloat\n    ,extra\tfloat\n    ,mta_tax\tfloat\n    ,tip_amount\tfloat\n    ,tolls_amount\tfloat\n    ,ehail_fee\tint\n    ,improvement_surcharge\tfloat\n    ,total_amount\tfloat\n    ,payment_type\tint\n    ,trip_type\tint\n    ,congestion_surcharge\tfloat\n    \n )\n    WITH (\n        LOCATION = 'raw/trip_data_green_csv/**',  -- OR\n        --LOCATION = 'raw/trip_data_green_csv/year=*/month=*/*.csv',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = csv_file_format, \n        REJECT_VALUE = 10 ,\n        REJECTED_ROW_LOCATION = 'rejections/trip_data_green_csv'\n         \n    );\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.trip_data_green_csv;\n\n\n\n----------------------------------------------------------\n-- External Table Name : bronze.trip_data_green_parquet\n----------------------------------------------------------\n\nIF OBJECT_ID('bronze.trip_data_green_parquet') IS NOT NULL\n        DROP EXTERNAL TABLE bronze.trip_data_green_parquet\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.trip_data_green_parquet\n    (    \n      VendorID\tint\n    ,lpep_pickup_datetime\tdatetime2(7)\n    ,lpep_dropoff_datetime\tdatetime2(7)\n    ,store_and_fwd_flag\tCHAR(1)\n    ,RatecodeID\tint\n    ,PULocationID\tint\n    ,DOLocationID\tint\n    ,passenger_count\tint\n    ,trip_distance\tfloat\n    ,fare_amount\tfloat\n    ,extra\tfloat\n    ,mta_tax\tfloat\n    ,tip_amount\tfloat\n    ,tolls_amount\tfloat\n    ,ehail_fee\tint\n    ,improvement_surcharge\tfloat\n    ,total_amount\tfloat\n    ,payment_type\tint\n    ,trip_type\tint\n    ,congestion_surcharge\tfloat\n )\n    WITH (\n        LOCATION = 'raw/trip_data_green_parquet/**',  -- OR\n        --LOCATION = 'raw/trip_data_green_parquet/year=*/month=*/*.parquet',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = parquet_file_format, \n        REJECT_VALUE = 10 ,\n        REJECTED_ROW_LOCATION = 'rejections/trip_data_green_parquet'\n         \n    );\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.trip_data_green_parquet;\n\n\n\n----------------------------------------------------------\n-- External Table Name : bronze.trip_data_green_delta\n----------------------------------------------------------\n\nIF OBJECT_ID('bronze.trip_data_green_delta') IS NOT NULL\n        DROP EXTERNAL TABLE bronze.trip_data_green_delta\nGO\n\nCREATE EXTERNAL TABLE  nyc_taxi_ldw.bronze.trip_data_green_delta\n    (    \n      VendorID\tint\n    ,lpep_pickup_datetime\tdatetime2(7)\n    ,lpep_dropoff_datetime\tdatetime2(7)\n    ,store_and_fwd_flag\tCHAR(1)\n    ,RatecodeID\tint\n    ,PULocationID\tint\n    ,DOLocationID\tint\n    ,passenger_count\tint\n    ,trip_distance\tfloat\n    ,fare_amount\tfloat\n    ,extra\tfloat\n    ,mta_tax\tfloat\n    ,tip_amount\tfloat\n    ,tolls_amount\tfloat\n    ,ehail_fee\tint\n    ,improvement_surcharge\tfloat\n    ,total_amount\tfloat\n    ,payment_type\tint\n    ,trip_type\tint\n    ,congestion_surcharge\tfloat\n )\n    WITH (\n        LOCATION = 'raw/trip_data_green_delta/',\n        DATA_SOURCE = nyc_taxi_src,\n        FILE_FORMAT = delta_file_format\n         \n    );\n\nGO\n\nSELECT TOP 100 * FROM nyc_taxi_ldw.bronze.trip_data_green_delta;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/4_Explore_CSV_Trip_Type')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "-- Read TripType.csv\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nUSE nyc_taxi_discovery\nGO\n\nSELECT *\nFROM OPENROWSET(\nBULK 'trip_type.tsv' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nPARSER_VERSION = '2.0',\nFIELDTERMINATOR = '\\t',\nFIRSTROW = 2,\nFIELDQUOTE = '\"'\n)WITH\n(\ntrip_type SMALLINT 1,\ntrip_type_desc VARCHAR(30) 2\n\n) AS trip ;",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/5_8_usp_Create_Silver_Trip_Type_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nCREATE OR ALTER PROCEDURE silver.usp_silver_trip_type\nAS\nBEGIN\n------------------------------------------------------------\n-- External Table Name :  silver.trip_type using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.trip_type') IS NOT NULL\n    DROP EXTERNAL TABLE silver.trip_type\n\nCREATE EXTERNAL TABLE silver.trip_type\nWITH(\n         DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/trip_type'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.trip_type ;\n\nEND\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/5_Create_Broze_Views')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n\n----------------------------------------\n-- View :  bronze.vw_rate_code\n----------------------------------------\n\nIF OBJECT_ID('bronze.vw_rate_code') IS NOT NULL\n    DROP VIEW bronze.vw_rate_code\n\n--DROP VIEW IF EXISTS bronze.vw_rate_code\n\nGO \n\nCREATE VIEW bronze.vw_rate_code\nAS\nSELECT * \nFROM OPENROWSET(\nBULK 'raw/rate_code.json' ,\nDATA_SOURCE = 'nyc_taxi_src' ,\nFORMAT = 'CSV',\nPARSER_VERSION = '1.0',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b', -- Vertical Tab\nROWTERMINATOR = '0x0b'  -- Vertical Tab\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS rate_code\nCROSS APPLY OPENJSON(jsonDoc)\nWITH(\n    rate_code_id SMALLINT,\n    rate_code_desc VARCHAR(20) '$.rate_code'\n);\n\nGO\nSELECT * FROM bronze.vw_rate_code\n\n\nGO\n\n\n----------------------------------------\n-- View :  bronze.vw_payment_type\n----------------------------------------\n\nIF OBJECT_ID('bronze.vw_payment_type') IS NOT NULL\n    DROP VIEW bronze.vw_payment_type\n\n--DROP VIEW IF EXISTS bronze.vw_payment_type\n\nGO \n\nCREATE VIEW bronze.vw_payment_type\nAS  \n    SELECT payment_type ,  description\n    FROM OPENROWSET(\n        BULK 'raw/payment_type.json' ,\n        DATA_SOURCE = 'nyc_taxi_src' ,\n        FORMAT = 'CSV',\n        PARSER_VERSION = '1.0',\n        FIELDTERMINATOR = '0x0b', -- Vertical Tab\n        FIELDQUOTE = '0x0b', -- Vertical Tab\n        ROWTERMINATOR = '0x0a' -- Hex Value of \\n\n        )WITH(  \n        jsonDoc NVARCHAR(MAX) \n    ) AS payment_type\n    CROSS APPLY OPENJSON(jsonDoc)\n    WITH (\n            payment_type SMALLINT ,\n            description  VARCHAR(15) '$.payment_type_desc'\n    );\n\nGO\nSELECT * FROM bronze.vw_payment_type\n\n\nGO\n\n------------------------------------------------------\n-- External Tables can't take benefit of Partition Pruning\n-- So we created a view \"vw_trip_data_green_csv\"\n------------------------------------------------------\n\nDROP VIEW IF EXISTS bronze.vw_trip_data_green_csv\nGO\n\nCREATE VIEW bronze.vw_trip_data_green_csv\nAS\n    SELECT\n        \n        result.filename() as file_name,\n        result.filepath(1) as year, -- 1 here is Position of WildCard  \n        result.filepath(2) as month, -- 2 here is Position of WildCard \n        result.filepath(3) as filename_from_file_path, -- 3 here is Position of WildCard \n        result.*\n    FROM\n        OPENROWSET(\n            BULK 'raw/trip_data_green_csv/year=*/month=*/*.csv' ,\n            DATA_SOURCE = 'nyc_taxi_src',\n            FORMAT = 'CSV',\n    PARSER_VERSION = '2.0',\n            HEADER_ROW = TRUE\n        )WITH(\n            VendorID\tint\n            ,lpep_pickup_datetime\tdatetime2(7)\n            ,lpep_dropoff_datetime\tdatetime2(7)\n            ,store_and_fwd_flag\tCHAR(1)\n            ,RatecodeID\tint\n            ,PULocationID\tint\n            ,DOLocationID\tint\n            ,passenger_count\tint\n            ,trip_distance\tfloat\n            ,fare_amount\tfloat\n            ,extra\tfloat\n            ,mta_tax\tfloat\n            ,tip_amount\tfloat\n            ,tolls_amount\tfloat\n            ,ehail_fee\tint\n            ,improvement_surcharge\tfloat\n            ,total_amount\tfloat\n            ,payment_type\tint\n            ,trip_type\tint\n            ,congestion_surcharge\tfloat\n            ) AS [result] \n        \nGO\n\nSELECT COUNT(1) from bronze.vw_trip_data_green_csv\n    WHERE year = '2020' and month='01'\n\nGO\n\nSELECT TOP 100 * from bronze.vw_trip_data_green_csv\n    WHERE year = '2020' and month='01'    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/5_Explore_JSON_Payment_Type')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "-- Read Payment_Type.json\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nUSE nyc_taxi_discovery\nGO\n\n--Using JSON_VALUE\n\nSELECT * \n, CAST(JSON_VALUE(jsonDoc,'$.payment_type') AS SMALLINT) AS payment_type\n, CAST(JSON_VALUE(jsonDoc,'$.payment_type_desc') AS VARCHAR(15)) AS payment_type_desc\nFROM OPENROWSET(\nBULK 'payment_type.json' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nPARSER_VERSION = '1.0',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b', -- Vertical Tab\nROWTERMINATOR = '0x0a' -- Hex Value of \\n\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS payment_type\n\n\n--Using OPENJSON\n\nSELECT payment_type ,  payment_type_desc\nFROM OPENROWSET(\nBULK 'payment_type.json' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b' -- Vertical Tab\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS payment_type\nCROSS APPLY OPENJSON(jsonDoc) \nWITH (\n        payment_type SMALLINT ,\n        payment_type_desc VARCHAR(15)\n);\n\n-- Rename Columns\n\nSELECT payment_type ,  description\nFROM OPENROWSET(\nBULK 'payment_type.json' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b' -- Vertical Tab\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS payment_type\nCROSS APPLY OPENJSON(jsonDoc) \nWITH (\n        payment_type SMALLINT ,\n        description VARCHAR(15) '$.payment_type_desc'\n);\n\n----------------------------------------------------------\n-- Reading data from JSON with Arrays\n----------------------------------------------------------\n\n\nSELECT * \n, CAST(JSON_VALUE(jsonDoc,'$.payment_type') AS SMALLINT) AS payment_type\n, CAST(JSON_VALUE(jsonDoc,'$.payment_type_desc[0].sub_type') AS VARCHAR(15)) AS payment_type_sub_type_0\n, CAST(JSON_VALUE(jsonDoc,'$.payment_type_desc[0].value') AS VARCHAR(15)) AS payment_type_value_0\n, CAST(JSON_VALUE(jsonDoc,'$.payment_type_desc[1].sub_type') AS VARCHAR(15)) AS payment_type_sub_type_1\n, CAST(JSON_VALUE(jsonDoc,'$.payment_type_desc[1].value') AS VARCHAR(15)) AS payment_type_value_1\n\nFROM OPENROWSET(\nBULK 'payment_type_array.json' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nPARSER_VERSION = '1.0',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b', -- Vertical Tab\nROWTERMINATOR = '0x0a' -- Hex Value of \\n\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS payment_type\n\n\n-- Use Open JSON to explode the Array\n\nSELECT * \nFROM OPENROWSET(\nBULK 'payment_type_array.json' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nPARSER_VERSION = '1.0',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b', -- Vertical Tab\nROWTERMINATOR = '0x0a' -- Hex Value of \\n\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS payment_type\nCROSS APPLY OPENJSON(jsonDoc)\nWITH(\n    payment_type SMALLINT,\n    payment_type_desc NVARCHAR(MAX) AS JSON\n)\nCROSS APPLY OPENJSON(payment_type_desc)\nWITH (\n\n    sub_type SMALLINT ,\n    payment_type_desc_value VARCHAR(20)  '$.value'\n);\n\n\n\n\n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/6_9_usp_Create_Silver_Vendor_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nCREATE OR ALTER PROCEDURE silver.usp_silver_vendor\nAS\nBEGIN\n------------------------------------------------------------\n-- External Table Name :  silver.vendor using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.vendor') IS NOT NULL\n    DROP EXTERNAL TABLE silver.vendor\n\nCREATE EXTERNAL TABLE silver.vendor\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/vendor'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.vendor;\n\nEND\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/6_Create_Silver_Taxi_Zone_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.taxi_zone using CETAS\n------------------------------------------------------------\n\nIF EXISTS (SELECT 1 FROM sys.external_tables WHERE name = 'taxi_zone')\n    DROP EXTERNAL TABLE silver.taxi_zone\nGO\n\nCREATE EXTERNAL TABLE silver.taxi_zone\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/taxi_zone'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.taxi_zone\n\nGO\n\nSELECT *\nFROM silver.taxi_zone\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/6_Explore_JSON_rate_code')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nUSE nyc_taxi_discovery\nGO\n\n----------------------------------------------------------\n-- Reading data from Standard JSON\n----------------------------------------------------------\n-- rate_code.json\n\nSELECT * \nFROM OPENROWSET(\nBULK 'rate_code.json' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nPARSER_VERSION = '1.0',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b', -- Vertical Tab\nROWTERMINATOR = '0x0b'  -- Vertical Tab\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS rate_code\nCROSS APPLY OPENJSON(jsonDoc)\nWITH(\n    rate_code_id SMALLINT,\n    rate_code_desc VARCHAR(20) '$.rate_code'\n);\n\n\n----------------------------------------------------------\n-- Reading data from Classic / Multiline JSON\n----------------------------------------------------------\n\nSELECT * \nFROM OPENROWSET(\nBULK 'rate_code_multi_line.json' ,\nDATA_SOURCE = 'nyc_taxi_data_raw' ,\nFORMAT = 'CSV',\nPARSER_VERSION = '1.0',\nFIELDTERMINATOR = '0x0b', -- Vertical Tab\nFIELDQUOTE = '0x0b', -- Vertical Tab\nROWTERMINATOR = '0x0b'  -- Vertical Tab\n)WITH(  \n    jsonDoc NVARCHAR(MAX)\n) AS rate_code\nCROSS APPLY OPENJSON(jsonDoc)\nWITH(\n    rate_code_id SMALLINT,\n    rate_code_desc VARCHAR(20) '$.rate_code'\n);\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/7_10_usp_Create_Silver_Rate_Code_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nCREATE OR ALTER PROCEDURE silver.usp_silver_rate_code\nAS\nBEGIN\n------------------------------------------------------------\n-- External Table Name :  silver.vendor using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.rate_code') IS NOT NULL\n    DROP EXTERNAL TABLE silver.rate_code\n\n\nCREATE EXTERNAL TABLE silver.rate_code\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/rate_code'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.vw_rate_code ;\n\nEND\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/7_Create_Silver_Calendar_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.calendar using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.calendar') IS NOT NULL\n    DROP EXTERNAL TABLE silver.calendar\nGO\n\nCREATE EXTERNAL TABLE silver.calendar\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/calendar'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.calendar\n\nGO\n\nSELECT *\nFROM silver.calendar\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/7_Explore_CSV_trip_data_green_csv')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "-- This is auto-generated code\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nUSE nyc_taxi_discovery\nGO\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=2020/month=01/green_tripdata_2020-01.csv',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n\n-- Select From a Folder\n\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=2020/month=01/*.csv',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n\n\n-- All Files in 2020 . Select Files from Subfolders\n\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=2020/month=*/*.csv',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n\n\n -- No Subfolders Specified\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=2020/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n   \n-- Get Data From More than One File\n\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK ('trip_data_green_csv/year=2020/month=01/*.csv'\n                ,'trip_data_green_csv/year=2020/month=03/*.csv' ),\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] ;\n\n\n-- Use More than 1 Wild Card Characters\n\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] ;\n\n \nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/month=*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] ;\n\n\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/*/*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] ;       \n\n\n-- File Metadata Function filename()\n\nSELECT\n    TOP 100  \n    result.filename() as file_name,\n    *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/month=*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] ;\n\n-- How Many Records in Each File\n\nSELECT\n    TOP 100  \n    result.filename() as file_name,\n    count(1) AS record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/month=*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] \n    GROUP BY result.filename()\n    ORDER BY  result.filename() \n\n-- Limit Data using filename()\n\nSELECT\n    TOP 100  \n    result.filename() as file_name,\n    count(1) AS record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/month=*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] \n    WHERE result.filename() in ( 'green_tripdata_2020-01.csv' ,'green_tripdata_2021-01.csv')\n    GROUP BY result.filename()\n    ORDER BY  result.filename() \n\n\n-- Use filepath function\n\nSELECT\n    TOP 100  \n    result.filename() as file_name,\n    result.filepath() as file_path,\n    COUNT(1) AS record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/month=*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] \n    WHERE result.filename() in ( 'green_tripdata_2020-01.csv' ,'green_tripdata_2021-01.csv')\n    GROUP BY  result.filepath() ,result.filename()\n    ORDER BY  result.filename() \n\n\nSELECT\n    TOP 100  \n    result.filename() as file_name,\n    result.filepath(1) as year, -- Position of WildCard  \n    result.filepath(2) as month, -- Position of WildCard \n    COUNT(1) AS record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/month=*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] \n    WHERE result.filename() in ( 'green_tripdata_2020-01.csv' ,'green_tripdata_2021-01.csv')\n    GROUP BY  result.filepath(1),result.filepath(2) ,result.filename()\n    ORDER BY  result.filename() \n\n\n-- Use filepath() in where clause\n\nSELECT\n    TOP 100  \n    result.filename() as file_name,\n    result.filepath(1) as year, -- 1 here is Position of WildCard  \n    result.filepath(2) as month, -- 2 here is Position of WildCard \n    result.filepath(3) as filename, -- 3 here is Position of WildCard \n    COUNT(1) AS record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_csv/year=*/month=*/*.csv' ,\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result] \n    WHERE result.filepath(1) = '2020'\n    AND result.filepath(2)  in ('06','07','08')\n    GROUP BY  result.filepath(1),result.filepath(2),result.filepath(3) ,result.filename()\n    ORDER BY  result.filename() , result.filepath(1) , result.filepath(2)\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/8_11_usp_Create_Silver_Payment_Type_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw/12_usp"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\nCREATE OR ALTER PROCEDURE silver.usp_silver_payment_type\nAS\nBEGIN\n------------------------------------------------------------\n-- External Table Name :  silver.payment_type using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.payment_type') IS NOT NULL\n    DROP EXTERNAL TABLE silver.payment_type\n\nCREATE EXTERNAL TABLE silver.payment_type\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/payment_type'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.vw_payment_type;\n\nEND\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/8_Create_Silver_Trip_Type_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.trip_type using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.trip_type') IS NOT NULL\n    DROP EXTERNAL TABLE silver.trip_type\nGO\n\nCREATE EXTERNAL TABLE silver.trip_type\nWITH(\n         DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/trip_type'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.trip_type\n\nGO\n\nSELECT *\nFROM silver.trip_type\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/8_Explore_Parquet_trip_data_green_parquet')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "-- This is auto-generated code\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nUSE nyc_taxi_discovery\nGO\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/part-00000-tid-6133789922049958496-2e489315-890a-4453-ae93-a104be9a6f06-106-1-c000.snappy.parquet',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n-- Reading Folder\n\nSELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n--Check DataType\nEXEC sp_describe_first_result_set N'SELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK ''trip_data_green_parquet/year=2020/month=01/'',\n        DATA_SOURCE = ''nyc_taxi_data_raw'',\n        FORMAT = ''PARQUET''\n    ) AS [result]'\n-------------------------------------------\n-- Define Columns and DataTypes\n-------------------------------------------\nSELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    ) WITH(\n\n    VendorID\tint\n    ,lpep_pickup_datetime\tdatetime2(7)\n    ,lpep_dropoff_datetime\tdatetime2(7)\n    ,store_and_fwd_flag\tCHAR(1)\n    ,RatecodeID\tint\n    ,PULocationID\tint\n    ,DOLocationID\tint\n    ,passenger_count\tint\n    ,trip_distance\tfloat\n    ,fare_amount\tfloat\n    ,extra\tfloat\n    ,mta_tax\tfloat\n    ,tip_amount\tfloat\n    ,tolls_amount\tfloat\n    ,ehail_fee\tint\n    ,improvement_surcharge\tfloat\n    ,total_amount\tfloat\n    ,payment_type\tint\n    ,trip_type\tint\n    ,congestion_surcharge\tfloat\n    ) AS [result]\n-------------------------------------------\n-- Read Specific Columns\n-------------------------------------------\nSELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n\n\n-------------------------------------------\n-- Wild Card Chanracters in the File Name\n-------------------------------------------\nSELECT\n    COUNT(1) -- 447770\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/*.parquet',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n\n-------------------------------------------\n-- All Parquet Files \n-------------------------------------------\nSELECT\n    COUNT(1) -- 2304517\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n\n-------------------------------------------\n-- All Parquet Files in Year =2020\n-------------------------------------------\nSELECT\n    COUNT(1) -- 1734051\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n\n-------------------------------------------\n-- All Parquet Files in Year =2020 and Month = Any\n-------------------------------------------\nSELECT \n    COUNT(1) -- 1734051\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=*/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n\n-------------------------------------------\n-- filename()\n-------------------------------------------\nSELECT \n    result.filename() as file_name\n    ,COUNT(1) AS file_record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=*/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]   \n    GROUP BY result.filename() \n\n\n-------------------------------------------\n-- filepath() and All Files recursively\n-------------------------------------------\nSELECT \n    result.filename() as file_name\n    ,result.filepath() as file_path\n    ,COUNT(1) AS file_record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]   \n    GROUP BY result.filepath(),result.filename() \n\n-------------------------------------------\n-- filepath() filters\n-------------------------------------------\n\nSELECT \n    result.filename() as file_name\n    ,result.filepath() as file_path\n    ,result.filepath(1) as Year\n    ,result.filepath(2) as Month\n    ,COUNT(1) AS file_record_count\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=*/month=*/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]\n    WHERE  result.filepath(1) = '2020'\n    AND result.filepath(2) IN ('06','07','08')\n    GROUP BY result.filepath(),result.filepath(1),result.filepath(2),result.filename() \n\n              \n   \n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/9_Create_Silver_Vendor_CETAS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/2_ldw"
				},
				"content": {
					"query": "USE nyc_taxi_ldw;\nGO\n\n------------------------------------------------------------\n-- External Table Name :  silver.vendor using CETAS\n------------------------------------------------------------\n\nIF OBJECT_ID('silver.vendor') IS NOT NULL\n    DROP EXTERNAL TABLE silver.vendor\nGO\n\nCREATE EXTERNAL TABLE silver.vendor\nWITH(\n        DATA_SOURCE = nyc_taxi_src\n        ,LOCATION = 'silver/vendor'\n        ,FILE_FORMAT = parquet_file_format,\n\n)\nAS\nSELECT *\nFROM bronze.vendor\n\nGO\n\nSELECT *\nFROM silver.vendor\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/9_Explore_Delta_trip_data_green_dela')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "1_NYC_Taxi/1_Discovery"
				},
				"content": {
					"query": "-- This is auto-generated code\n-- Connect to Built in Serverless SQL Pool\n-- Connect to nyc_taxi_discovery Database\n\nUSE nyc_taxi_discovery\nGO\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_delta/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'DELTA'\n    ) AS trip_data\n\n-- Reading Folder : It will give you an error . as Delta_Log folder is missing in the folder\n\nSELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'DELTA'\n    ) AS [result]\n\n--Check DataType\nEXEC sp_describe_first_result_set N'SELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK ''trip_data_green_delta/'',\n        DATA_SOURCE = ''nyc_taxi_data_raw'',\n        FORMAT = ''DELTA''\n    ) AS [result]'\n-------------------------------------------\n-- Define Columns and DataTypes\n-------------------------------------------\nSELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_delta/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'DELTA'\n    ) WITH(\n\n    VendorID\tint\n    ,lpep_pickup_datetime\tdatetime2(7)\n    ,lpep_dropoff_datetime\tdatetime2(7)\n    ,store_and_fwd_flag\tCHAR(1)\n    ,RatecodeID\tint\n    ,PULocationID\tint\n    ,DOLocationID\tint\n    ,passenger_count\tint\n    ,trip_distance\tfloat\n    ,fare_amount\tfloat\n    ,extra\tfloat\n    ,mta_tax\tfloat\n    ,tip_amount\tfloat\n    ,tolls_amount\tfloat\n    ,ehail_fee\tint\n    ,improvement_surcharge\tfloat\n    ,total_amount\tfloat\n    ,payment_type\tint\n    ,trip_type\tint\n    ,congestion_surcharge\tfloat\n    ,year VARCHAR(4)\n    ,month VARCHAR(2)\n    ) AS [result]\n-------------------------------------------\n-- Read Specific Columns : Always Mention the Partition Columns in the WITH Clause. Here it is year & month\n-------------------------------------------\nSELECT\n    TOP 100 * \nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_delta/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'DELTA'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ,year VARCHAR(4)\n    ,month VARCHAR(2)\n    ) AS [result] \n\n-------------------------------------------\n-- !!!! No Partition Applied . so the dat read is more\n-------------------------------------------\n\n SELECT\n   COUNT(DISTINCT payment_type)\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_delta/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'DELTA'\n    )AS [result]    \n\n-------------------------------------------\n-- Apply the partition in WHERE clause\n-------------------------------------------\n SELECT\n   COUNT(DISTINCT payment_type)\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_delta/',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'DELTA'\n    )AS [result]  \n    WHERE year = '2020'   AND month = '01'\n\n\n\n-------------------------------------------\n-- Wild Card Chanracters in the File Name  : Not Valid in DELTA as you can't query folders and subfloders\n-------------------------------------------\n/*\nSELECT\n    COUNT(1) -- 447770\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/month=01/*.parquet',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n\n-------------------------------------------\n-- All Parquet Files   : Not Valid in DELTA as you can't query folders and subfloders\n-------------------------------------------\nSELECT\n    COUNT(1) -- 2304517\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n\n-------------------------------------------\n-- All Parquet Files in Year =2020  : Not Valid in DELTA as you can't query folders and subfloders\n-------------------------------------------\nSELECT\n    COUNT(1) -- 1734051\nFROM\n    OPENROWSET(\n        BULK 'trip_data_green_parquet/year=2020/**',\n        DATA_SOURCE = 'nyc_taxi_data_raw',\n        FORMAT = 'PARQUET'\n    )WITH(    \n     tip_amount\tfloat    \n    ,trip_type\tint\n    ) AS [result]    \n*/\n-------------------------------------------\n-- All Parquet Files in Year =2020 and Month = Any  : Not Valid in DELTA as you can't query folders and subfloders\n-------------------------------------------\n-- SELECT \n--     COUNT(1) -- 1734051\n-- FROM\n--     OPENROWSET(\n--         BULK 'trip_data_green_parquet/year=2020/month=*/',\n--         DATA_SOURCE = 'nyc_taxi_data_raw',\n--         FORMAT = 'PARQUET'\n--     )WITH(    \n--      tip_amount\tfloat    \n--     ,trip_type\tint\n--     ) AS [result]    \n\n-------------------------------------------\n-- filename()  : Not Valid in DELTA as you can't query folders and subfloders\n-------------------------------------------\n-- SELECT \n--     result.filename() as file_name\n--     ,COUNT(1) AS file_record_count\n-- FROM\n--     OPENROWSET(\n--         BULK 'trip_data_green_parquet/year=2020/month=*/',\n--         DATA_SOURCE = 'nyc_taxi_data_raw',\n--         FORMAT = 'PARQUET'\n--     )WITH(    \n--      tip_amount\tfloat    \n--     ,trip_type\tint\n--     ) AS [result]   \n--     GROUP BY result.filename() \n\n\n-------------------------------------------\n-- filepath() and All Files recursively  : Not Valid in DELTA as you can't query folders and subfloders\n-------------------------------------------\n-- SELECT \n--     result.filename() as file_name\n--     ,result.filepath() as file_path\n--     ,COUNT(1) AS file_record_count\n-- FROM\n--     OPENROWSET(\n--         BULK 'trip_data_green_parquet/**',\n--         DATA_SOURCE = 'nyc_taxi_data_raw',\n--         FORMAT = 'PARQUET'\n--     )WITH(    \n--      tip_amount\tfloat    \n--     ,trip_type\tint\n--     ) AS [result]   \n--     GROUP BY result.filepath(),result.filename() \n\n-------------------------------------------\n-- filepath() filters  : Not Valid in DELTA as you can't query folders and subfloders\n-------------------------------------------\n\n-- SELECT \n--     result.filename() as file_name\n--     ,result.filepath() as file_path\n--     ,result.filepath(1) as Year\n--     ,result.filepath(2) as Month\n--     ,COUNT(1) AS file_record_count\n-- FROM\n--     OPENROWSET(\n--         BULK 'trip_data_green_parquet/year=*/month=*/',\n--         DATA_SOURCE = 'nyc_taxi_data_raw',\n--         FORMAT = 'PARQUET'\n--     )WITH(    \n--      tip_amount\tfloat    \n--     ,trip_type\tint\n--     ) AS [result]\n--     WHERE  result.filepath(1) = '2020'\n--     AND result.filepath(2) IN ('06','07','08')\n--     GROUP BY result.filepath(),result.filepath(1),result.filepath(2),result.filename() \n\n              \n   \n\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_discovery",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Query Parquet files')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"content": {
					"query": "/* Covid-19 ECDC cases opendata set */\n\n/* Read parquet file  */\nSELECT TOP 10 *\nFROM OPENROWSET(\n    BULK 'https://pandemicdatalake.blob.core.windows.net/public/curated/covid-19/ecdc_cases/latest/ecdc_cases.parquet',\n    FORMAT = 'parquet') as rows\n\n\n/* Explicitly specify schema */\nSELECT TOP 10 *\nFROM OPENROWSET(\n        BULK 'https://pandemicdatalake.blob.core.windows.net/public/curated/covid-19/ecdc_cases/latest/ecdc_cases.parquet',\n        FORMAT = 'parquet'\n    ) WITH ( date_rep date, cases int, geo_id varchar(6) ) as rows\n\n\n/* New York City Taxi opendata set */\n\n/* Query set of parquet files */\nSELECT\n    YEAR(tpepPickupDateTime),\n    passengerCount,\n    COUNT(*) AS cnt\nFROM\n    OPENROWSET(\n        BULK 'https://azureopendatastorage.blob.core.windows.net/nyctlc/yellow/puYear=2018/puMonth=*/*.snappy.parquet',\n        FORMAT='PARQUET'\n    ) WITH (\n        tpepPickupDateTime DATETIME2,\n        passengerCount INT\n    ) AS nyc\nGROUP BY\n    passengerCount,\n    YEAR(tpepPickupDateTime)\nORDER BY\n    YEAR(tpepPickupDateTime),\n    passengerCount;\n\n\n/* Automatic schema inference */\nSELECT TOP 10 *\nFROM\n    OPENROWSET(\n        BULK 'https://azureopendatastorage.blob.core.windows.net/nyctlc/yellow/puYear=2018/puMonth=*/*.snappy.parquet',\n        FORMAT='PARQUET'\n    ) AS nyc\n\n\n/* Query partitioned data */\nSELECT\n    YEAR(tpepPickupDateTime),\n    passengerCount,\n    COUNT(*) AS cnt\nFROM\n    OPENROWSET(\n        BULK 'https://azureopendatastorage.blob.core.windows.net/nyctlc/yellow/puYear=*/puMonth=*/*.snappy.parquet',\n        FORMAT='PARQUET'\n    ) nyc\nWHERE\n    nyc.filepath(1) = 2017\n    AND nyc.filepath(2) IN (1, 2, 3)\n    AND tpepPickupDateTime BETWEEN CAST('1/1/2017' AS datetime) AND CAST('3/31/2017' AS datetime)\nGROUP BY\n    passengerCount,\n    YEAR(tpepPickupDateTime)\nORDER BY\n    YEAR(tpepPickupDateTime),\n    passengerCount;\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "demo",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Query Taxi Zone')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Demo"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'https://azuresynapsecoursedl.dfs.core.windows.net/demo/taxi_zone.csv',\n        FORMAT = 'CSV',\nPARSER_VERSION = '2.0'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL script 1')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"content": {
					"query": "\n\nselect * from sys.dm_external_data_processed\n\n\nselect * from sys.configurations where name like '%Data Pro%'\n\n\n EXEC sp_set_data_processed_limit @type= N'monthly', @limit_tb = 1 ;\n\n EXEC  sp_set_data_processed_limit @type= N'Weekly', @limit_tb = 1 ;\n\n  EXEC  sp_set_data_processed_limit @type= N'Daily', @limit_tb = 1 ;",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL script 2')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"content": {
					"query": "SELECT TOP (100) [pu_location_id]\n,[do_location_id]\n,[total_trip_count]\n,[total_fare_amount]\n,[year]\n,[month]\n FROM [nyc_taxi_ldw_spark].[dbo].[trip_data_green_agg]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "nyc_taxi_ldw_spark",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_spark_create_gold_trip_data_green_agg')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "synpsesparkpool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "38cb096f-3393-453b-b8f1-525fb6ff4db0"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/1101ab50-b9a6-4719-afe5-7586e598ea9f/resourceGroups/synapse-course-rg/providers/Microsoft.Synapse/workspaces/synapse-course-workspace/bigDataPools/synpsesparkpool",
						"name": "synpsesparkpool",
						"type": "Spark",
						"endpoint": "https://synapse-course-workspace.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/synpsesparkpool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Trip Data Aggregation \n",
							"### Group By Columns\n",
							"1. year\n",
							"2. Month\n",
							"3. Pickup Location ID\n",
							"4. Drop Off Location ID\n",
							"\n",
							"### Aggregated Columns\n",
							"1. Total Trip Count\n",
							"2. Total Fare Amount\n",
							"\n",
							"### Purpose of the notebook\n",
							"\n",
							"Demonstrate the integration between Spark Pool and Serverless SQL Pool\n",
							"\n",
							"1. Create the aggregated table in Spark Pool\n",
							"2. Access the data from Serverless SQL Pool "
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#Set the folder paths so that it can be used later. \n",
							"bronze_folder_path = 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/raw'\n",
							"silver_folder_path = 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/silver'\n",
							"gold_folder_path = 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/gold'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#Set the spark config to be able to get the partitioned columns year and month as strings rather than integers\n",
							"spark.conf.set(\"spark.sql.sources.partitionColumnTypeInference.enabled\", \"false\")"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"microsoft": {
								"language": "sparksql"
							},
							"collapsed": false
						},
						"source": [
							"%%sql\n",
							"\n",
							"-- Create database to which we are going to write the data\n",
							"\n",
							"CREATE DATABASE IF NOT EXISTS nyc_taxi_ldw_spark\n",
							"LOCATION 'abfss://nyc-taxi-data@azuresynapsecoursedl.dfs.core.windows.net/gold';"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Read the silver data to be processed. \n",
							"trip_data_green_df = spark.read.parquet(f\"{silver_folder_path}/trip_data_green\") "
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Perform the required aggregations\n",
							"# 1. Total trip count\n",
							"# 2. Total fare amount\n",
							"from pyspark.sql.functions import *\n",
							"\n",
							"trip_data_green_agg_df = trip_data_green_df \\\n",
							"                        .groupBy(\"year\", \"month\", \"pu_location_id\", \"do_location_id\") \\\n",
							"                        .agg(count(lit(1)).alias(\"total_trip_count\"),\n",
							"                        round(sum(\"fare_amount\"), 2).alias(\"total_fare_amount\"))"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Write the aggregated data to the gold table for consumption\n",
							"\n",
							"trip_data_green_agg_df.write.mode(\"overwrite\").partitionBy(\"year\", \"month\").format(\"parquet\").saveAsTable(\"nyc_taxi_ldw_spark.trip_data_green_agg\")"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"microsoft": {
								"language": "sparksql"
							},
							"collapsed": false
						},
						"source": [
							"%%sql\r\n",
							"\r\n",
							"select * from nyc_taxi_ldw_spark.trip_data_green_agg limit 100"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"microsoft": {
								"language": "sparksql"
							}
						},
						"source": [
							"%%sql"
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/1_synapse_link_query_heartbit_cosmosdb')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "synpsesparkpool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "7f30e2b5-638d-41a9-9f1b-dc1b6518e408"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/1101ab50-b9a6-4719-afe5-7586e598ea9f/resourceGroups/synapse-course-rg/providers/Microsoft.Synapse/workspaces/synapse-course-workspace/bigDataPools/synpsesparkpool",
						"name": "synpsesparkpool",
						"type": "Spark",
						"endpoint": "https://synapse-course-workspace.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/synpsesparkpool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"# Read from Cosmos DB analytical store into a Spark DataFrame and display 10 rows from the DataFrame\n",
							"# To select a preferred list of regions in a multi-region Cosmos DB account, add .option(\"spark.cosmos.preferredRegions\", \"<Region1>,<Region2>\")\n",
							"\n",
							"df = spark.read\\\n",
							"    .format(\"cosmos.olap\")\\\n",
							"    .option(\"spark.synapse.linkedService\", \"ls_cosmos_nyc_taxi_data\")\\\n",
							"    .option(\"spark.cosmos.container\", \"Heartbeat\")\\\n",
							"    .load()\n",
							"\n",
							"display(df.limit(10))"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df.select(\"deviceId\",\"DeviceLocation.latitude\",\"DeviceLocation.longitude\",\"DeviceLocation.*\").show(10,truncate=False)"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df.printSchema()"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							""
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Notebook 1')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "12cfc31c-197f-4b11-a9ff-e29c35ad4a37"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "python"
					},
					"language_info": {
						"name": "python"
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"source": [
							"# NOTE\n",
							"\n",
							"For Spark 3 Cosmos DB connector has slightly different configuration. Please select different snippest if a Spark 3.1 + pool is attached."
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Write a Spark DataFrame into a Cosmos DB container\n",
							"# To select a preferred list of regions in a multi-region Cosmos DB account, add .option(\"spark.cosmos.preferredRegions\", \"<Region1>,<Region2>\")\n",
							"\n",
							"# For Spark 2.4\n",
							"YOURDATAFRAME.write\\\n",
							"    .format(\"cosmos.oltp\")\\\n",
							"    .option(\"spark.synapse.linkedService\", \"ls_cosmos_nyc_taxi_data\")\\\n",
							"    .option(\"spark.cosmos.container\", \"Heartbeat\")\\\n",
							"    .option(\"spark.cosmos.write.upsertEnabled\", \"true\")\\\n",
							"    .mode('append')\\\n",
							"    .save()\n",
							"\n",
							"# For Spark 3.1 +\n",
							"# YOURDATAFRAME.write\\\n",
							"#     .format(\"cosmos.oltp\")\\\n",
							"#     .option(\"spark.synapse.linkedService\", \"ls_cosmos_nyc_taxi_data\")\\\n",
							"#     .option(\"spark.cosmos.container\", \"Heartbeat\")\\\n",
							"#     .option(\"spark.cosmos.write.strategy\", \"ItemOverwrite\")\\\n",
							"#     .option(\"spark.cosmos.write.bulk.enabled\", \"true\")\\\n",
							"#     .mode('append')\\\n",
							"#     .save()"
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/synpsesparkpool')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": 5
				},
				"autoScale": {
					"enabled": false,
					"maxNodeCount": 3,
					"minNodeCount": 3
				},
				"nodeCount": 3,
				"nodeSize": "Small",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "3.3",
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": true,
				"annotations": []
			},
			"dependsOn": [],
			"location": "centralindia"
		}
	]
}